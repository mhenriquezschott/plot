# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled02.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
import os
import shutil
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm

#import threading
import json
import re

import csv

from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from matplotlib.colors import Normalize
from matplotlib.cm import ScalarMappable

#from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas


from PyQt5.QtWidgets import (QApplication, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QDateEdit,
                             QPushButton, QFrame, QGraphicsView, QGraphicsScene, QToolButton, QCheckBox, QGroupBox, QGridLayout, QStatusBar, QGraphicsPixmapItem, QMenu, QAction, QSpinBox, QGraphicsRectItem, QFileDialog)
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QPixmap, QCursor, QPen, QIcon, QBrush, QColor, QPolygonF, QFont, QPainter, QFontMetrics, QTransform
from PyQt5.QtCore import Qt, QDate, QSize, QPointF, QRectF, QTimer
from PyQt5.QtWidgets import QWidget, QGraphicsItem, QGraphicsEllipseItem, QGraphicsRectItem, QFileDialog, QGraphicsItem, QGraphicsPolygonItem, QGraphicsScene, QGraphicsPixmapItem
from PyQt5 import QtWidgets, QtCore 

from PyQt5.QtTest import QTest


import datetime
from datetime import datetime
import random
import sqlite3

#from PyQt5.QtGui import QIcon, QPixmap, QFont


import sys
from PyQt5.QtWidgets import (
    QApplication, QDialog, QVBoxLayout, QHBoxLayout, QGroupBox,
    QLabel, QComboBox, QPushButton, QGraphicsView, QGraphicsScene, QMessageBox, QLineEdit, QDialogButtonBox
)
from PyQt5.QtGui import QPixmap, QIcon, QFont
from PyQt5.QtCore import Qt

from visualworkertool import VisualWorkerTool

from plotviewerdialog import PlotViewerDialog
from multiselectcombobox import MultiSelectComboBox

from zcpwindow import ZCPWindow


class PlantLayoutWindow(QDialog):
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Plant-Layout Organizational Tool (PLOT)")
        
        #self._save_lock = threading.Lock()

        self.operator_count = 0
        self.initUI()
    
    def initUI(self):
        self.setFixedSize(1390, 940)
        
        self.filters_group = QtWidgets.QGroupBox(self)
        self.filters_group.setGeometry(QtCore.QRect(10, 0, 1371, 181))
        self.filters_group.setObjectName("filters_group")
        self.plantfilter_group = QtWidgets.QGroupBox(self.filters_group)
        self.plantfilter_group.setGeometry(QtCore.QRect(10, 20, 981, 61))
        self.plantfilter_group.setObjectName("plantfilter_group")
        
        self.plantid_label = QtWidgets.QLabel(self.plantfilter_group)
        self.plantid_label.setGeometry(QtCore.QRect(10, 33, 67, 17))
        self.plantid_label.setObjectName("plantid_label")
        
        self.plant_combo = QtWidgets.QComboBox(self.plantfilter_group)
        self.plant_combo.setGeometry(QtCore.QRect(70, 30, 171, 25))
        self.plant_combo.setObjectName("plant_combo")
        #self.plant_combo.addItem("Default")  # Add "Default" to plant_combo
        self.plant_combo.currentIndexChanged.connect(self.plantComboIndexChanged)
        
        #self.section_combo = QtWidgets.QComboBox(self.plantfilter_group)
        self.section_combo = MultiSelectComboBox(self.plantfilter_group)
        self.section_combo.setGeometry(QtCore.QRect(350, 30, 151, 25))
        self.section_combo.setObjectName("section_combo")
        #self.section_combo.addItem("All")  # Add "All" to section_combo
        self.section_combo.addSelectableItem("All")  # Add "All" to section_combo
        #self.section_combo.currentIndexChanged.connect(self.sectionComboIndexChanged)
        self.section_combo.itemCheckStateChanged.connect(self.sectionComboSelectionChanged)  # Connect signal to handler
        
        self.sectionid_label = QtWidgets.QLabel(self.plantfilter_group)
        self.sectionid_label.setGeometry(QtCore.QRect(270, 33, 81, 17))
        self.sectionid_label.setObjectName("sectionid_label")
        
        
        
        
        #self.line_combo = QtWidgets.QComboBox(self.plantfilter_group)
        self.line_combo = MultiSelectComboBox(self.plantfilter_group)
        self.line_combo.setGeometry(QtCore.QRect(590, 30, 151, 25))
        self.line_combo.setObjectName("line_combo")
        #self.line_combo.addItem("All")  # Add "All" to line_combo
        self.line_combo.addSelectableItem("All")  # Add "All" to line_combo
        #self.line_combo.currentIndexChanged.connect(self.lineComboIndexChanged)
        self.line_combo.itemCheckStateChanged.connect(self.lineComboSelectionChanged)  # Connect signal to handler
        
        
        self.lineid_label = QtWidgets.QLabel(self.plantfilter_group)
        self.lineid_label.setGeometry(QtCore.QRect(530, 33, 61, 17))
        self.lineid_label.setObjectName("lineid_label")
        
        
        
        
        self.stationid_label = QtWidgets.QLabel(self.plantfilter_group)
        self.stationid_label.setGeometry(QtCore.QRect(770, 33, 81, 17))
        self.stationid_label.setObjectName("stationid_label")

        
        
        #self.station_combo = QtWidgets.QComboBox(self.plantfilter_group)
        self.station_combo = MultiSelectComboBox(self.plantfilter_group)
        self.station_combo.setGeometry(QtCore.QRect(850, 30, 121, 25))
        self.station_combo.setObjectName("station_combo")
        #self.station_combo.addItem("All")  # Add "All" to station_combo
        self.station_combo.addSelectableItem("All")  # Add "All" to station_combo
        self.station_combo.currentIndexChanged.connect(self.stationComboIndexChanged)
        
        
        
        
        self.shiftfilter_group = QtWidgets.QGroupBox(self.filters_group)
        self.shiftfilter_group.setGeometry(QtCore.QRect(1000, 20, 151, 61))
        self.shiftfilter_group.setObjectName("shiftfilter_group")
        
        self.shiftid_label = QtWidgets.QLabel(self.shiftfilter_group)
        self.shiftid_label.setGeometry(QtCore.QRect(10, 33, 61, 17))
        self.shiftid_label.setObjectName("shiftid_label")        
        
        
        
        #self.shift_combo = QtWidgets.QComboBox(self.shiftfilter_group)
        self.shift_combo = MultiSelectComboBox(self.shiftfilter_group)
        self.shift_combo.setGeometry(QtCore.QRect(70, 30, 71, 25))
        self.shift_combo.setObjectName("shift_combo")
        #self.shift_combo.addItem("1")  # Add "1" to shift_combo
        self.shift_combo.addSelectableItem("1")  # Add "1" to shift_combo
  
        
        
        self.workerfilter_group = QtWidgets.QGroupBox(self.filters_group)
        self.workerfilter_group.setGeometry(QtCore.QRect(210, 80, 481, 91))
        self.workerfilter_group.setCheckable(True)
        self.workerfilter_group.setChecked(False)
        self.workerfilter_group.setObjectName("workerfilter_group")
        self.gender_combo = QtWidgets.QComboBox(self.workerfilter_group)
        self.gender_combo.setGeometry(QtCore.QRect(70, 30, 161, 25))
        self.gender_combo.setObjectName("gender_combo")
        
        self.gender_combo.setObjectName("gender_combo")
        self.gender_combo.addItems(["Both", "Female", "Male"])  # Add gender options
        self.gender_combo.setCurrentText("Both")  # Set "Both" as default

        self.ageflt_label = QtWidgets.QLabel(self.workerfilter_group)
        self.ageflt_label.setGeometry(QtCore.QRect(30, 60, 67, 17))
        self.ageflt_label.setObjectName("ageflt_label")
        self.agefrom_edit = QtWidgets.QLineEdit(self.workerfilter_group)
        self.agefrom_edit.setGeometry(QtCore.QRect(70, 60, 61, 25))
        self.agefrom_edit.setObjectName("agefrom_edit")
        self.ageto_label = QtWidgets.QLabel(self.workerfilter_group)
        self.ageto_label.setGeometry(QtCore.QRect(140, 60, 21, 17))
        self.ageto_label.setObjectName("ageto_label")
        self.ageto_edit = QtWidgets.QLineEdit(self.workerfilter_group)
        self.ageto_edit.setGeometry(QtCore.QRect(160, 60, 71, 25))
        self.ageto_edit.setObjectName("ageto_edit")
        self.weightfrom_edit = QtWidgets.QLineEdit(self.workerfilter_group)
        self.weightfrom_edit.setGeometry(QtCore.QRect(310, 30, 61, 25))
        self.weightfrom_edit.setObjectName("weightfrom_edit")
        self.weightftl_label = QtWidgets.QLabel(self.workerfilter_group)
        self.weightftl_label.setGeometry(QtCore.QRect(250, 30, 67, 17))
        self.weightftl_label.setObjectName("weightftl_label")
        self.weightto_edit = QtWidgets.QLineEdit(self.workerfilter_group)
        self.weightto_edit.setGeometry(QtCore.QRect(400, 30, 71, 25))
        self.weightto_edit.setObjectName("weightto_edit")
        self.label_10 = QtWidgets.QLabel(self.workerfilter_group)
        self.label_10.setGeometry(QtCore.QRect(380, 30, 21, 17))
        self.label_10.setObjectName("label_10")
        self.heightfrom_edit = QtWidgets.QLineEdit(self.workerfilter_group)
        self.heightfrom_edit.setGeometry(QtCore.QRect(310, 60, 61, 25))
        self.heightfrom_edit.setObjectName("heightfrom_edit")
        self.heightflt_label = QtWidgets.QLabel(self.workerfilter_group)
        self.heightflt_label.setGeometry(QtCore.QRect(250, 60, 67, 17))
        self.heightflt_label.setObjectName("heightflt_label")
        self.heightto_edit = QtWidgets.QLineEdit(self.workerfilter_group)
        self.heightto_edit.setGeometry(QtCore.QRect(400, 60, 71, 25))
        self.heightto_edit.setObjectName("heightto_edit")
        self.label_12 = QtWidgets.QLabel(self.workerfilter_group)
        self.label_12.setGeometry(QtCore.QRect(380, 60, 21, 17))
        self.label_12.setObjectName("label_12")
        self.genderflt_label = QtWidgets.QLabel(self.workerfilter_group)
        self.genderflt_label.setGeometry(QtCore.QRect(30, 30, 67, 17))
        self.genderflt_label.setObjectName("genderflt_label")
        self.toolfilter_group = QtWidgets.QGroupBox(self.filters_group)
        self.toolfilter_group.setGeometry(QtCore.QRect(10, 80, 191, 91))
        self.toolfilter_group.setObjectName("toolfilter_group")
        self.toolsid_label = QtWidgets.QLabel(self.toolfilter_group)
        self.toolsid_label.setGeometry(QtCore.QRect(10, 30, 67, 17))
        self.toolsid_label.setObjectName("toolsid_label")
        self.tool_combo = QtWidgets.QComboBox(self.toolfilter_group)
        self.tool_combo.setGeometry(QtCore.QRect(70, 30, 111, 25))
        self.tool_combo.setObjectName("tool_combo")
        self.tool_combo.addItem("LiFFT")  # Add "Default" to plant_combo
        
        self.toolsfiltersettings_button = QtWidgets.QPushButton(self.toolfilter_group)
        self.toolsfiltersettings_button.setGeometry(QtCore.QRect(10, 60, 171, 21))
        self.toolsfiltersettings_button.setObjectName("toolsfiltersettings_button")
        self.otheroptionsfilter_group = QtWidgets.QGroupBox(self.filters_group)
        self.otheroptionsfilter_group.setGeometry(QtCore.QRect(700, 80, 451, 91))
        self.otheroptionsfilter_group.setCheckable(True)
        self.otheroptionsfilter_group.setChecked(False)
        self.otheroptionsfilter_group.setObjectName("otheroptionsfilter_group")
        self.option1a_option = QtWidgets.QCheckBox(self.otheroptionsfilter_group)
        self.option1a_option.setGeometry(QtCore.QRect(40, 30, 92, 23))
        self.option1a_option.setObjectName("option1a_option")
        self.option1b_option = QtWidgets.QCheckBox(self.otheroptionsfilter_group)
        self.option1b_option.setGeometry(QtCore.QRect(300, 30, 92, 23))
        self.option1b_option.setObjectName("option1b_option")
        self.option1c_radio = QtWidgets.QRadioButton(self.otheroptionsfilter_group)
        self.option1c_radio.setGeometry(QtCore.QRect(40, 60, 112, 23))
        self.option1c_radio.setObjectName("option1c_radio")
        self.option1d_radio = QtWidgets.QRadioButton(self.otheroptionsfilter_group)
        self.option1d_radio.setGeometry(QtCore.QRect(300, 60, 112, 23))
        self.option1d_radio.setObjectName("option1d_radio")
        self.clearfilter_button = QtWidgets.QPushButton(self.filters_group)
        self.clearfilter_button.setGeometry(QtCore.QRect(1160, 30, 201, 71))
        self.clearfilter_button.setObjectName("clearfilter_button")
        self.clearfilter_button.clicked.connect(self.clearfilterButtonClicked)
        self.applyfilter_button = QtWidgets.QPushButton(self.filters_group)
        self.applyfilter_button.setGeometry(QtCore.QRect(1160, 100, 201, 71))
        self.applyfilter_button.setObjectName("applyfilter_button")
        self.applyfilter_button.clicked.connect(self.applyfilterButtonClicked)
        
        
        
        self.plantlayout_image = QGraphicsView(self)
        self.plantlayout_image.setGeometry(QtCore.QRect(70, 200, 970, 580))
        self.plantlayout_image.setObjectName("plantlayout_image")
        
        # Disable scrollbars permanently
        #self.plantlayout_image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        #self.plantlayout_image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)


        self.plantlayout_scene = QGraphicsScene(self)
        self.plantlayout_scene.setSceneRect(0, 0, 970, 580)  # Match the QGraphicsView size
        self.plantlayout_image.setScene(self.plantlayout_scene)
        #self.plantlayout_scene.setSceneRect(0, 0, 970, 580)  # Match the QGraphicsView size
        #self.loadImage("../images/layout01.png", self.plantlayout_scene, self.plantlayout_image, 0.9, 0.9)
        
        #self.plantlayout_image.setMouseTracking(True)  # Enable mouse tracking
        #self.plantlayout_image.mouseMoveEvent = self.plantlayoutImageMouseMoved
        self.plantlayout_image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.plantlayout_image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        


        # Flag to indicate full scene zoom mode.
        self.fullSceneZoomMode = False
        
        # Install an event filter on the view to catch mouse clicks.
        self.plantlayout_image.viewport().installEventFilter(self)
        
        
        self.summary_group = QtWidgets.QGroupBox(self)
        self.summary_group.setGeometry(QtCore.QRect(1050, 180, 331, 601))
        self.summary_group.setObjectName("summary_group")
        
        
        #self.summaryplot_image = QGraphicsView(self.summary_group)
        #self.summaryplot_image.setGeometry(QtCore.QRect(10, 30, 310, 230))
        #self.summaryplot_image.setObjectName("summaryplot_image")
        #self.summaryplot_image.mousePressEvent = self.onPlotClicked
        
        
        # Create a FigureCanvas instance
        # Create an empty figure with a white background
        self.initplotfig = Figure(figsize=(3.1, 2.3), facecolor='white')  # Matches 310x230 px size

        # Create the FigureCanvas from the empty figure
        self.summaryplot_canvas = FigureCanvas(self.initplotfig)
        self.summaryplot_canvas.setGeometry(10, 30, 310, 230)  # Set the same geometry
        self.summaryplot_canvas.setObjectName("summaryplot_canvas")
        # Assign a mouse press event handler
        self.summaryplot_canvas.mousePressEvent = self.onPlotClicked
        
        # Attach the canvas to summary_group (without a layout)
        self.summaryplot_canvas.setParent(self.summary_group)
        self.summaryplot_canvas.setGeometry(10, 30, 310, 230)  # Match previous QGraphicsView position and size
        
        #self.summaryplot_scene = QGraphicsScene(self)
        #self.summaryplot_scene.setSceneRect(0, 0, 310, 230)  # Match the QGraphicsView size
        #self.summaryplot_image.setScene(self.summaryplot_scene)
        #self.loadImage("../images/plottest01.png", self.summaryplot_scene, self.summaryplot_image, 0.95, 0.95)
        #self.summaryplot_image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        #self.summaryplot_image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        
        self.summarytitle_label = QtWidgets.QLabel(self.summary_group)
        self.summarytitle_label.setGeometry(QtCore.QRect(10, 270, 311, 31))
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.summarytitle_label.setFont(font)
        self.summarytitle_label.setObjectName("summarytitle_label")
        self.summaryresult1_label = QtWidgets.QLabel(self.summary_group)
        self.summaryresult1_label.setGeometry(QtCore.QRect(10, 340, 311, 21))
        self.summaryresult1_label.setObjectName("summaryresult1_label")
        self.summaryresult2_label = QtWidgets.QLabel(self.summary_group)
        self.summaryresult2_label.setGeometry(QtCore.QRect(10, 360, 311, 21))
        self.summaryresult2_label.setObjectName("summaryresult2_label")
        self.summarysettings_button = QtWidgets.QPushButton(self.summary_group)
        self.summarysettings_button.setGeometry(QtCore.QRect(10, 540, 311, 51))
        self.summarysettings_button.setObjectName("summarysettings_button")
        self.summaryresult3_label = QtWidgets.QLabel(self.summary_group)
        self.summaryresult3_label.setGeometry(QtCore.QRect(10, 380, 311, 21))
        self.summaryresult3_label.setObjectName("summaryresult3_label")
        self.summaryresult4_label = QtWidgets.QLabel(self.summary_group)
        self.summaryresult4_label.setGeometry(QtCore.QRect(10, 400, 311, 21))
        self.summaryresult4_label.setObjectName("summaryresult4_label")
        self.summaryresult5_label = QtWidgets.QLabel(self.summary_group)
        self.summaryresult5_label.setGeometry(QtCore.QRect(10, 420, 311, 21))
        self.summaryresult5_label.setObjectName("summaryresult5_label")
        self.summaryresult6_label = QtWidgets.QLabel(self.summary_group)
        self.summaryresult6_label.setGeometry(QtCore.QRect(10, 440, 311, 21))
        self.summaryresult6_label.setObjectName("summaryresult6_label")
        self.summaryresult7_label = QtWidgets.QLabel(self.summary_group)
        self.summaryresult7_label.setGeometry(QtCore.QRect(10, 460, 311, 21))
        self.summaryresult7_label.setObjectName("summaryresult7_label")
        
        self.summaryplot_combo = QtWidgets.QComboBox(self.summary_group)
        self.summaryplot_combo.setGeometry(QtCore.QRect(10, 270, 311, 25))
        self.summaryplot_combo.setObjectName("summaryplot_combo")
        # **Summary Plot Selection ComboBox**
        self.summaryplot_combo.addItem("Total Worker Distribution by Tool")
        self.summaryplot_combo.addItem("Worker Risk Distribution by Gender & Tool")
        self.summaryplot_combo.addItem("Worker Risk Distribution by Age & Tool")
        self.summaryplot_combo.addItem("Risk Distribution by Station")
        self.summaryplot_combo.addItem("Worker Risk Levels (Heatmap)")
        self.summaryplot_combo.addItem("Risk Heatmap Across Stations")
        self.summaryplot_combo.addItem("Worker Distribution by Gender & Tool")
        self.summaryplot_combo.addItem("Scatter Plot: Risk vs. Age of Workers")
        self.summaryplot_combo.addItem("Cumulative Risk Over Time")
        self.summaryplot_combo.currentIndexChanged.connect(self.onSummaryPlotChanged)

        
        
        
        self.toolsgraphic_group = QtWidgets.QGroupBox(self)
        self.toolsgraphic_group.setGeometry(QtCore.QRect(10, 180, 61, 601))
        self.toolsgraphic_group.setObjectName("toolsgraphic_group")
        
        #self.grtool1_button = QtWidgets.QPushButton(self.toolsgraphic_group)
        #self.grtool1_button.setGeometry(QtCore.QRect(10, 30, 41, 41))
        #self.grtool1_button.setObjectName("grtool1_button")
        self.grtool1_button = self.createImageButton(
        self.toolsgraphic_group,
            "../images/open_icon01.png",  # Image for button 1
            QtCore.QRect(10, 30, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool1_button.setObjectName("grtool1_button")
        self.grtool1_button.clicked.connect(self.grtool1ButtonClicked)


        
        self.grtool2_button = self.createImageButton(
        self.toolsgraphic_group,
            "../images/save_icon01.png",  # Image for button 2
            QtCore.QRect(10, 80, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool2_button.setObjectName("grtool2_button")
        self.grtool2_button.clicked.connect(self.grtool2ButtonClicked)

        self.grtool3_button = self.createImageButton(
            self.toolsgraphic_group,
            "../images/zoomimg.png",  # Image for button 3
            QtCore.QRect(10, 130, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool3_button.setObjectName("grtool3_button")
        self.grtool3_button.clicked.connect(self.grtool3ButtonClicked)
        
        self.grtool4_button = self.createImageButton(
            self.toolsgraphic_group,
            "../images/zoomimg02.png",  # Image for button 4
            QtCore.QRect(10, 180, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool4_button.setObjectName("grtool4_button")
        self.grtool4_button.clicked.connect(self.grtool4ButtonClicked)
                
        self.grtool5_button = self.createImageButton(
            self.toolsgraphic_group,
            "../images/zoomrest01.png",  # Image for button 5
            QtCore.QRect(10, 230, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool5_button.setObjectName("grtool5_button")
        self.grtool5_button.clicked.connect(self.grtool5ButtonClicked)
        
        
        self.grtool7_button = self.createImageButton(
            self.toolsgraphic_group,
            "../images/transparent_icon01.png",  # Image for button 7
            QtCore.QRect(10, 280, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool7_button.setObjectName("grtool7_button")
        self.grtool7_button.clicked.connect(self.grtool7ButtonClicked)     
        
        self.grtool6_button = self.createImageButton(
            self.toolsgraphic_group,
            "../images/phototake_icon01.png",  # Image for button 6
            QtCore.QRect(10, 330, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool6_button.setObjectName("grtool6_button")
        self.grtool6_button.clicked.connect(self.grtool6ButtonClicked)
        
         
        self.grtool8_button = self.createImageButton(
            self.toolsgraphic_group,
            "../images/resizeimg.png",  # Image for button 8
            QtCore.QRect(10, 380, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool8_button.setObjectName("grtool8_button")
        self.grtool8_button.clicked.connect(self.grtool8ButtonClicked)
        
        
        self.grtool9_button = self.createImageButton(
            self.toolsgraphic_group,
            "../images/export_icon01.png",  # Image for button 9
            QtCore.QRect(10, 430, 41, 41),
            icon_size=(32, 32)  # Set icon size
        )
        self.grtool9_button.setObjectName("grtool9_button")
        self.grtool9_button.clicked.connect(self.grtool9ButtonClicked)
        
        #self.grtool10_button = self.createImageButton(
        #    self.toolsgraphic_group,
        #    "../images/zoomimg.png",  # Image for button 10
        #    QtCore.QRect(10, 480, 41, 41),
        #    icon_size=(32, 32)  # Set icon size
        #)
        #self.grtool10_button.setObjectName("grtool10_button")
        
        #self.grtool11_button = self.createImageButton(
        #    self.toolsgraphic_group,
        #    "../images/resizeimg.png",  # Image for button 11
        #    QtCore.QRect(10, 530, 41, 41),
        #    icon_size=(32, 32)  # Set icon size
        #)
        #self.grtool11_button.setObjectName("grtool11_button")
        
        
        self.workerinfo_group = QtWidgets.QGroupBox(self)
        self.workerinfo_group.setGeometry(QtCore.QRect(10, 780, 1031, 151))
        self.workerinfo_group.setObjectName("workerinfo_group")
        self.workeridinfolbl_label = QtWidgets.QLabel(self.workerinfo_group)
        self.workeridinfolbl_label.setGeometry(QtCore.QRect(10, 30, 81, 17))
        self.workeridinfolbl_label.setObjectName("workeridinfolbl_label")
        self.workerComboBox = QtWidgets.QComboBox(self.workerinfo_group)
        self.workerComboBox.setGeometry(QtCore.QRect(90, 30, 721, 25))
        self.workerComboBox.setObjectName("workerComboBox")
        self.workerComboBox.currentIndexChanged.connect(self.workerComboIndexChanged)

        
        
        # Order Button
        self.orderInfo_button = QtWidgets.QPushButton(self.workerinfo_group)
        self.orderInfo_button.setIcon(QIcon("../images/alphaorder01.png"))
        self.orderInfo_button.setFixedSize(30, 30)  # Square button
        self.orderInfo_button.setGeometry(QtCore.QRect(820, 30, 30, 30))
        self.orderInfo_button.setIconSize(QtCore.QSize(25, 25))
        self.orderInfo_button.setObjectName("orderInfo_button")
        self.orderInfo_button.clicked.connect(self.orderInfoButtonClicked)
        
        # Search Button
        self.searchInfo_button = QtWidgets.QPushButton(self.workerinfo_group)
        self.searchInfo_button.setIcon(QIcon("../images/search_icon.png"))
        self.searchInfo_button.setFixedSize(30, 30)  # Square button
        self.searchInfo_button.setGeometry(QtCore.QRect(850, 30, 30, 30))
        self.searchInfo_button.setIconSize(QtCore.QSize(25, 25))
        self.searchInfo_button.setObjectName("searchInfo_button")
        self.searchInfo_button.clicked.connect(self.searchInfoWorkerClicked)
        
        
        #self.orderInfo_button = QtWidgets.QPushButton(self.workerinfo_group)
        #self.orderInfo_button.setGeometry(QtCore.QRect(820, 30, 30, 30))
        #self.orderInfo_button.setObjectName("orderInfo_button")
        #self.searchInfo_button = QtWidgets.QPushButton(self.workerinfo_group)
        #self.searchInfo_button.setGeometry(QtCore.QRect(850, 30, 30, 30))
        #self.searchInfo_button.setObjectName("searchInfo_button")

        
        
        
        
        
        
        self.saveallinfo_button = QtWidgets.QPushButton(self.workerinfo_group)
        self.saveallinfo_button.setGeometry(QtCore.QRect(920, 110, 101, 31))
        self.saveallinfo_button.setObjectName("saveallinfo_button")
        # Connect the button to the handler
        self.saveallinfo_button.clicked.connect(self.saveAllInfoClicked)

        self.xview_input = QtWidgets.QLineEdit(self.workerinfo_group)
        self.xview_input.setGeometry(QtCore.QRect(910, 30, 41, 25))
        self.xview_input.setObjectName("xview_input")
        self.yview_input = QtWidgets.QLineEdit(self.workerinfo_group)
        self.yview_input.setGeometry(QtCore.QRect(980, 30, 41, 25))
        self.yview_input.setObjectName("yview_input")
        self.yview_label = QtWidgets.QLabel(self.workerinfo_group)
        self.yview_label.setGeometry(QtCore.QRect(960, 30, 16, 20))
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.yview_label.setFont(font)
        self.yview_label.setObjectName("yview_label")
        self.xview_label = QtWidgets.QLabel(self.workerinfo_group)
        self.xview_label.setGeometry(QtCore.QRect(890, 30, 21, 20))
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.xview_label.setFont(font)
        self.xview_label.setObjectName("xview_label")


        self.scaleallinfolbl_label = QtWidgets.QLabel(self.workerinfo_group)
        self.scaleallinfolbl_label.setGeometry(QtCore.QRect(920, 80, 51, 20))
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.scaleallinfolbl_label.setFont(font)
        self.scaleallinfolbl_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.scaleallinfolbl_label.setObjectName("scaleallinfolbl_label")
        self.scaleallinfo_input = QtWidgets.QLineEdit(self.workerinfo_group)
        self.scaleallinfo_input.setGeometry(QtCore.QRect(980, 80, 41, 25))
        self.scaleallinfo_input.setObjectName("scaleallinfo_input")
        
        
        
        self.gridLayoutWidget = QtWidgets.QWidget(self.workerinfo_group)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(10, 60, 801, 81))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        #self.gridLayoutWidget.setStyleSheet("border: 1px solid black; padding: 2px;")
        
        self.info_gridLayout = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.info_gridLayout.setContentsMargins(0, 0, 0, 0)
        self.info_gridLayout.setObjectName("info_gridLayout")
        
        self.ageinfolbl_label = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.ageinfolbl_label.setFont(font)
        self.ageinfolbl_label.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.ageinfolbl_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.ageinfolbl_label.setObjectName("ageinfolbl_label")
        self.info_gridLayout.addWidget(self.ageinfolbl_label, 0, 1, 1, 1)
        self.lastinfo_button = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.lastinfo_button.setObjectName("lastinfo_button")
        self.lastinfo_button.clicked.connect(self.lastInfoButtonClicked)  
        
        self.info_gridLayout.addWidget(self.lastinfo_button, 2, 8, 1, 1)
        self.yinfolbl_label = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.yinfolbl_label.setFont(font)
        self.yinfolbl_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.yinfolbl_label.setObjectName("yinfolbl_label")
        self.info_gridLayout.addWidget(self.yinfolbl_label, 1, 3, 1, 1)
        self.yinfo_input = QtWidgets.QLineEdit(self.gridLayoutWidget)
        self.yinfo_input.setObjectName("yinfo_input")
        self.info_gridLayout.addWidget(self.yinfo_input, 1, 4, 1, 1)
        self.ageinfo_label = QtWidgets.QLabel(self.gridLayoutWidget)
        self.ageinfo_label.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.ageinfo_label.setObjectName("ageinfo_label")
        self.info_gridLayout.addWidget(self.ageinfo_label, 0, 2, 1, 1)
        self.firstinfo_button = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.firstinfo_button.setObjectName("firstinfo_button")
        self.firstinfo_button.clicked.connect(self.firstInfoButtonClicked)  
        
        self.info_gridLayout.addWidget(self.firstinfo_button, 2, 1, 1, 1)
        self.xinfolbl_label_2 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.xinfolbl_label_2.setFont(font)
        self.xinfolbl_label_2.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.xinfolbl_label_2.setObjectName("xinfolbl_label_2")
        self.info_gridLayout.addWidget(self.xinfolbl_label_2, 1, 1, 1, 1)
        self.xinfo_input = QtWidgets.QLineEdit(self.gridLayoutWidget)
        self.xinfo_input.setObjectName("xinfo_input")
        self.info_gridLayout.addWidget(self.xinfo_input, 1, 2, 1, 1)
        self.weightinfo_label = QtWidgets.QLabel(self.gridLayoutWidget)
        self.weightinfo_label.setObjectName("weightinfo_label")
        self.info_gridLayout.addWidget(self.weightinfo_label, 0, 6, 1, 1)
        self.scaleinfolbl_label_2 = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.scaleinfolbl_label_2.setFont(font)
        self.scaleinfolbl_label_2.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.scaleinfolbl_label_2.setObjectName("scaleinfolbl_label_2")
        self.info_gridLayout.addWidget(self.scaleinfolbl_label_2, 1, 5, 1, 1)
        self.sexinfolbl_label = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.sexinfolbl_label.setFont(font)
        self.sexinfolbl_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.sexinfolbl_label.setObjectName("sexinfolbl_label")
        self.info_gridLayout.addWidget(self.sexinfolbl_label, 0, 3, 1, 1)
        self.weightinfolbl_label = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.weightinfolbl_label.setFont(font)
        self.weightinfolbl_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.weightinfolbl_label.setObjectName("weightinfolbl_label")
        self.info_gridLayout.addWidget(self.weightinfolbl_label, 0, 5, 1, 1)
        self.heightinfolbl_label = QtWidgets.QLabel(self.gridLayoutWidget)
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.heightinfolbl_label.setFont(font)
        self.heightinfolbl_label.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.heightinfolbl_label.setObjectName("heightinfolbl_label")
        self.info_gridLayout.addWidget(self.heightinfolbl_label, 0, 7, 1, 1)
        self.heightinfo_label = QtWidgets.QLabel(self.gridLayoutWidget)
        self.heightinfo_label.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.heightinfo_label.setObjectName("heightinfo_label")
        self.info_gridLayout.addWidget(self.heightinfo_label, 0, 8, 1, 1)
        self.previousinfo_button = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.previousinfo_button.setObjectName("previousinfo_button")
        self.previousinfo_button.clicked.connect(self.previousInfoButtonClicked)  
        self.info_gridLayout.addWidget(self.previousinfo_button, 2, 2, 1, 1)
        self.scaleinfo_input = QtWidgets.QLineEdit(self.gridLayoutWidget)
        self.scaleinfo_input.setObjectName("scaleinfo_input")
        self.info_gridLayout.addWidget(self.scaleinfo_input, 1, 6, 1, 1)
        self.sexinfo_label = QtWidgets.QLabel(self.gridLayoutWidget)
        self.sexinfo_label.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.sexinfo_label.setObjectName("sexinfo_label")
        self.info_gridLayout.addWidget(self.sexinfo_label, 0, 4, 1, 1)
        self.nextinfo_button = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.nextinfo_button.setObjectName("nextinfo_button")
        self.nextinfo_button.clicked.connect(self.nextInfoButtonClicked)  
        
        self.info_gridLayout.addWidget(self.nextinfo_button, 2, 7, 1, 1)
        self.visibleinfo_check = QtWidgets.QCheckBox(self.gridLayoutWidget)
        self.visibleinfo_check.setObjectName("visibleinfo_check")
        self.info_gridLayout.addWidget(self.visibleinfo_check, 0, 0, 1, 1)
        self.enableinfo_check = QtWidgets.QCheckBox(self.gridLayoutWidget)
        self.enableinfo_check.setObjectName("enableinfo_check")
        self.info_gridLayout.addWidget(self.enableinfo_check, 1, 0, 1, 1)
        self.lockinfo_check = QtWidgets.QCheckBox(self.gridLayoutWidget)
        self.lockinfo_check.setObjectName("lockinfo_check")
        self.info_gridLayout.addWidget(self.lockinfo_check, 2, 0, 1, 1)
        self.saveinfo_button = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.saveinfo_button.setObjectName("saveinfo_button")
        self.saveinfo_button.clicked.connect(self.saveInfoButtonClicked)  
        self.info_gridLayout.addWidget(self.saveinfo_button, 2, 5, 1, 1)

        
        
        
       
        
        
       
        self.outcome_group = QtWidgets.QGroupBox(self)
        self.outcome_group.setGeometry(QtCore.QRect(1050, 780, 331, 151))
        self.outcome_group.setObjectName("outcome_group")
        self.outcome_image = QtWidgets.QGraphicsView(self.outcome_group)
        self.outcome_image.setGeometry(QtCore.QRect(10, 30, 101, 111))
        self.outcome_image.setObjectName("outcome_image")
        self.outcometitle_label = QtWidgets.QLabel(self.outcome_group)
        self.outcometitle_label.setGeometry(QtCore.QRect(120, 30, 81, 21))
        font = QFont()
        font.setBold(True)
        font.setWeight(75)
        self.outcometitle_label.setFont(font)
        self.outcometitle_label.setObjectName("outcometitle_label")
        self.outcomemore_button = QtWidgets.QPushButton(self.outcome_group)
        self.outcomemore_button.setGeometry(QtCore.QRect(120, 110, 201, 31))
        self.outcomemore_button.setObjectName("outcomemore_button")
        self.outcomeresult1_label = QtWidgets.QLabel(self.outcome_group)
        self.outcomeresult1_label.setGeometry(QtCore.QRect(120, 40, 201, 51))
        self.outcomeresult1_label.setObjectName("outcomeresult1_label")


        # Status Bar # TODO: check why I don't have status var
        self.statusBar = QStatusBar(self)
        #self.addWidget(self.statusBar)
        
        self.setUIText()
        #QtCore.QMetaObject.connectSlotsByName(Dialog)
        
        #self.statusBar.showMessage(f"Mouse Coordinates: X=")
        

        self.isNumberOrder = False
        self.visual_worker_tools = []
        self.scale_factor  = 1 
         # Check if a project has been created from the parent window
        if self.parent().projectFileCreated:
            self.loadTools()
            self.loadPlants()
            self.loadSections()
            self.loadLines()
            self.loadStations()
            
            self.loadShifts()
            
           
            # **Check if Plant Combo is Empty or Blank**
            if self.plant_combo.count() == 0 or not self.plant_combo.currentText().strip():
                # Clear multi-selection combo boxes properly
                self.section_combo.model().clear()
                self.line_combo.model().clear()
                self.station_combo.model().clear()
            else:
                if self.section_combo.count() > 0:
                    first_item = self.section_combo.model().item(0)
                    if first_item:
                        first_item.setCheckState(Qt.Checked)  # Check the first item
                
                    self.section_combo.lineEdit().setText("All") 
                    if self.section_combo.lineEdit().text() == "All":
                        for i in range(self.section_combo.count()):
                            self.section_combo.model().item(i).setCheckState(Qt.Checked)
           
            
                if self.line_combo.count() > 0:
                    first_item = self.line_combo.model().item(0)
                    if first_item:
                        first_item.setCheckState(Qt.Checked)  # Check the first item
                
                    self.line_combo.lineEdit().setText("All") 
                    if self.line_combo.lineEdit().text() == "All":
                        for i in range(self.line_combo.count()):
                            self.line_combo.model().item(i).setCheckState(Qt.Checked)
           
            
                if self.station_combo.count() > 0:
                    first_item = self.station_combo.model().item(0)
                    if first_item:
                        first_item.setCheckState(Qt.Checked)  # Check the first item
                
                    self.station_combo.lineEdit().setText("All") 
                    if self.station_combo.lineEdit().text() == "All":
                        for i in range(self.station_combo.count()):
                            self.station_combo.model().item(i).setCheckState(Qt.Checked)
           
           
           
            self.loadWorkers(0)
            selected_worker = self.workerComboBox.currentText().strip()
            # Extract worker ID (format: "<worker_id> (Last, First)")
            worker_id = selected_worker.split(" ")[0] if " " in selected_worker else selected_worker
            self.loadWorkerDetails(worker_id)
            
            #self.loadTools()
            #self.loadPlants()
            #self.loadSections()
            #self.loadLines()
            #self.loadStations()
            
            #self.loadShifts()
    
            #self.loadPlantImage()
            QTimer.singleShot(0, self.loadPlantImage)
            
            #self.loadVisualWorkerTools()
            # **Ensure loadVisualWorkerTools only runs after the window is fully loaded**
            #QTimer.singleShot(0, self.loadVisualWorkerTools)
            #self.loadSummary()
            QTimer.singleShot(0, self.loadSummary)
            #self.loadOutcome()
            QTimer.singleShot(0, self.loadOutcome)
            
            #self.loadVisualWorkerTools()
            QTimer.singleShot(0, self.loadVisualWorkerTools)
            #self.updateWorkerBorders()
            QTimer.singleShot(0, self.updateWorkerBorders)
        
        
        else:
            self.section_combo.model().clear()
            self.line_combo.model().clear()
            self.station_combo.model().clear()
            self.shift_combo.model().clear()
        
        

    # Override the closeEvent method to handle the window close event
    # Override the closeEvent method to handle the window close event
    def closeEvent(self, event):
        self.saveVars()
        
        # Accept the close event
        event.accept()
 
    
    def saveVars(self):
        """Extracts values from PlantLayout window controls and stores them in the parent variables."""
    
        # Ensure parent exists before proceeding
        if not self.parent():
            #print("Error: No parent window found.")
            return
    
    
        # Store empty values in parent's variables
        self.parent().editPlantName = ""
        self.parent().editSectionName = ""
        self.parent().editLineName = ""
        self.parent().editStationName = ""
        self.parent().editShiftName = ""
        self.parent().editToolID = ""
        self.parent().editWorkerID = ""


        # **Check if any VisualWorkerTool has getLoadIntoTool() as True**
        if not any(worker.getLoadIntoTool() for worker in getattr(self, "visual_worker_tools", [])):
            #print("Skipping saveVars: No VisualWorkerTool has getLoadIntoTool set to True.")
            return  # Exit function if no valid tools found
        
        
        # **Check if any VisualWorkerTool has getLoadIntoTool() as True**
        selected_worker = next(
            (worker for worker in getattr(self, "visual_worker_tools", []) if worker.getLoadIntoTool()), 
            None
        )

        # If no worker is found, exit the function
        if not selected_worker:
            return  # Exit function if no valid tools found
        
        # Retrieve the unit from the selected worker
        unit = selected_worker.getUnit()


        # Extract values from UI labels
        plant_name = self.plantinfo_label.text().strip()
        section_name = self.sectioninfo_label.text().strip()
        line_name = self.lineinfo_label.text().strip()
        station_id = self.stationinfo_label.text().strip()
        shift_id = self.shiftinfo_label.text().strip()
        tool_id = self.tool_combo.currentText().strip()
    
        # Extract worker ID with formatted display if available
        worker_id = self.workerComboBox.currentText().strip()
    
        # Store values in parent's variables
        self.parent().editPlantName = plant_name
        self.parent().editSectionName = section_name
        self.parent().editLineName = line_name
        self.parent().editStationName = station_id
        self.parent().editShiftName = shift_id
        self.parent().editToolID = tool_id
        self.parent().editWorkerID = worker_id  # Keep the formatted worker ID
        
        self.parent().editUnit = unit 
        #print("PlantLayout variables saved to parent successfully.")


    def updateStatusBar(self, pos):
        self.statusBar.showMessage(f"Mouse Coordinates: X={pos.x()}, Y={pos.y()}")

    
    def plantlayoutImageMouseMoved(self, event):
        #super().mouseMoveEvent(event)
        """Handles mouse move events over the plant layout image."""
        cursor_pos = event.pos()
        #print(f"Mouse moved to: {cursor_pos.x()}, {cursor_pos.y()}")
        # Ensure the parent has the required UI elements
        if hasattr(self, 'xview_input') and hasattr(self, 'yview_input'):
            self.xview_input.setText(str(cursor_pos.x()))
            self.yview_input.setText(str(cursor_pos.y()))
        
        super().mouseMoveEvent(event)
        
    
    # Navigation Handlers
    def firstInfoButtonClicked(self):
        if self.workerComboBox.count() > 0:
            self.workerComboBox.setCurrentIndex(0)
 
    def previousInfoButtonClicked(self):
        current_index = self.workerComboBox.currentIndex()
        if current_index > 0:
            self.workerComboBox.setCurrentIndex(current_index - 1)
 
    def nextInfoButtonClicked(self):
        current_index = self.workerComboBox.currentIndex()
        if current_index < self.workerComboBox.count() - 1:
            self.workerComboBox.setCurrentIndex(current_index + 1)
            
    def lastInfoButtonClicked(self):
        if self.workerComboBox.count() > 0:
            self.workerComboBox.setCurrentIndex(self.workerComboBox.count() - 1)
 
 
 
 
    def setUIText(self):
        _translate = QtCore.QCoreApplication.translate
        self.filters_group.setTitle("Filters")
        self.plantfilter_group.setTitle("Plant")
        self.plantid_label.setText("Plant ID:")
        self.sectionid_label.setText("Section ID:")
        self.lineid_label.setText("Line  ID:")
        self.stationid_label.setText("Station  ID:")
        self.shiftfilter_group.setTitle("Shift")
        self.shiftid_label.setText("Shift ID:")
        self.workerfilter_group.setTitle("Worker")
        self.ageflt_label.setText("Age:")
        self.ageto_label.setText("to")
        self.weightftl_label.setText("Weight:")
        self.label_10.setText("to")
        self.heightflt_label.setText("Height:")
        self.label_12.setText("to")
        self.genderflt_label.setText("Sex :")
        self.toolfilter_group.setTitle("Tool")
        self.toolsid_label.setText("Tool ID:")
        self.toolsfiltersettings_button.setText("Settings")
        self.otheroptionsfilter_group.setTitle("Other Options")
        self.option1a_option.setText("Option 1A")
        self.option1b_option.setText("Option 1B")
        self.option1c_radio.setText("Option 1C")
        self.option1d_radio.setText("Option 1D")
        self.clearfilter_button.setText("Clear Filters")
        self.applyfilter_button.setText("Apply Filters")
        self.summary_group.setTitle("Summary")
        self.summarytitle_label.setText("<b>Summary:</b>")
        self.summaryresult1_label.setText("<b>Total Workers:</b> 0")
        self.summaryresult2_label.setText("<b>Average Age:</b> 0 ")
        self.summarysettings_button.setText("Settings")
        self.summaryresult3_label.setText("<b>Males:</b> 0")
        self.summaryresult4_label.setText("<b>Females:</b> 0")
        self.summaryresult5_label.setText("<b>Avg. Cumulative Damage:</b>  0%")
        self.summaryresult6_label.setText("<b>Risk job:</b> 0%")
        self.summaryresult7_label.setText("<b>Avg. Job Risk:</b> 0%")
        self.toolsgraphic_group.setTitle("Tools")
        
        self.workerinfo_group.setTitle("Worker")
        self.workeridinfolbl_label.setText("Worker ID:")
        self.ageinfolbl_label.setText("Age: ")
        self.ageinfo_label.setText("35")
        self.sexinfolbl_label.setText("Sex:")
        self.sexinfo_label.setText("Female")
        self.weightinfo_label.setText("90")
        self.weightinfolbl_label.setText("Weight (lbs):")
        self.heightinfo_label.setText("6.5")
        self.heightinfolbl_label.setText("Height (ft):")
        self.visibleinfo_check.setText("Visible")
        self.enableinfo_check.setText("Enable")
        self.scaleallinfolbl_label.setText("Scale:")
        self.scaleallinfo_input.setText("1.0")
        self.outcome_group.setTitle("Outcome")
        self.outcometitle_label.setText("Highlights: ")
        self.outcomemore_button.setText("More")
        self.saveallinfo_button.setText("Save All")
        
        self.lockinfo_check.setText("Lock")
        #self.xinfolbl_label.setText("X:")
        #self.xinfo_label.setText("30")
        #self.yinfo_label.setText("30")
        #self.yinfolbl_label.setText("Y:")
        self.yinfolbl_label.setText("Y:")
        self.xinfolbl_label_2.setText("X:")
        self.xinfo_input.setText("0")
        self.yinfo_input.setText("0")
        #self.xcurrentlbl_label.setText("Current X:")
        #self.ycurrentlbl_label.setText("Current Y:")
        #self.xinfo_label.setText("0")
        #self.yinfo_label.setText("0")
        #self.plantinfolbl_label.setText("Plant:")
        #self.plantinfo_label.setText("Default")
        #self.sectioninfolbl_label.setText("Section:")
        #self.sectioninfo_label.setText("Default")
        #self.lineinfo_label.setText("Default")
        #self.lineinfolbl_label.setText("Line:")
        #self.stationinfolbl_label.setText("Station:")
        #self.stationinfo_label.setText("Default")
        #self.shiftinfolbl_label.setText("Shift:")
        #self.shiftinfo_label.setText("1")
        
        self.firstinfo_button.setText("|<")
        self.lastinfo_button.setText(">|")
        self.previousinfo_button.setText("<")
        self.nextinfo_button.setText(">")          
        self.saveinfo_button.setText("Save")      
        self.scaleinfolbl_label_2.setText("Scale:")
        self.scaleinfo_input.setText("1.0")
        
        
        #self.toolinfolbl_label.setText("Tool:")
        #self.toolinfo_label.setText("LiFFT")
        self.xview_input.setText("9999")
        self.yview_input.setText("9999")
        self.yview_label.setText("Y:")
        self.xview_label.setText("X:")
        
        
        self.outcomeresult1_label.setText("- Station 1 present high-risk from LiFFT")
        
       
 
    def createImageButton(self, parent, image_path, geometry, icon_size=(32, 32)):
        button = QtWidgets.QPushButton(parent)
        button.setGeometry(geometry)
        button.setIcon(QIcon(image_path))
        button.setIconSize(QtCore.QSize(*icon_size))  # Set the size of the icon
        return button
        
        

    def applyfilterButtonClicked(self):
       	#self.loadPlantImage()
       	
       	self.loadWorkers(0)
        selected_worker = self.workerComboBox.currentText().strip()
        # Extract worker ID (format: "<worker_id> (Last, First)")
        worker_id = selected_worker.split(" ")[0] if " " in selected_worker else selected_worker
        self.loadWorkerDetails(worker_id)
        
      
        
        #self.loadTools()
        #self.loadPlants()
        #self.loadShifts()

        self.loadPlantImage()
        
      
        
        # **Restore previous selections**
        def restore_combo_selection(combo, selected_items, current_text):
            for i in range(combo.count()):
                item = combo.model().item(i)
                item.setCheckState(Qt.Unchecked)
                if item.text() in selected_items:
                    item.setCheckState(Qt.Checked)
            combo.lineEdit().setText(current_text)
        
        
        
        # **Save current selections and checked items**
        selected_shifts = [self.shift_combo.itemText(i) for i in range(self.shift_combo.count())
                           if self.shift_combo.model().item(i).checkState() == Qt.Checked]
        current_shift_text = self.shift_combo.lineEdit().text().strip()

        
        selected_sections = [self.section_combo.itemText(i) for i in range(self.section_combo.count())
                             if self.section_combo.model().item(i).checkState() == Qt.Checked]
        current_section_text = self.section_combo.lineEdit().text().strip()
        
        selected_lines = [self.line_combo.itemText(i) for i in range(self.line_combo.count())
                          if self.line_combo.model().item(i).checkState() == Qt.Checked]
        current_line_text = self.line_combo.lineEdit().text().strip()
        
        selected_stations = [self.station_combo.itemText(i) for i in range(self.station_combo.count())
                             if self.station_combo.model().item(i).checkState() == Qt.Checked]
        current_station_text = self.station_combo.lineEdit().text().strip()
        
        # **Reload Section, Line, and Station Lists**
        self.loadSections()
        restore_combo_selection(self.section_combo, selected_sections, current_section_text)
        
        self.loadLines()
        restore_combo_selection(self.line_combo, selected_lines, current_line_text)
        
        self.loadStations()
        restore_combo_selection(self.station_combo, selected_stations, current_station_text)
        
        self.loadShifts()
        restore_combo_selection(self.shift_combo, selected_shifts, current_shift_text)
         
         
         
            
        #self.loadVisualWorkerTools()
        # **Ensure loadVisualWorkerTools only runs after the window is fully loaded**
        #QTimer.singleShot(0, self.loadVisualWorkerTools)
        self.loadVisualWorkerTools()
        
        self.updateWorkerBorders()
        
        
        self.loadSummary()
        self.loadOutcome()
        
        self.summaryplot_combo.setCurrentIndex(0)
        
        # TODO: check why is not working!!!
        # **Check if scrollbars exist and reset their position**
        if self.plantlayout_image.horizontalScrollBar().isVisible():
            self.plantlayout_image.horizontalScrollBar().setValue(0)

        if self.plantlayout_image.verticalScrollBar().isVisible():
            self.plantlayout_image.verticalScrollBar().setValue(0)
       	
       	
    def clearfilterButtonClicked(self):
       	#self.addOperator()
       	self.resetFilters()
    
    
    def resetFilters(self):
        """Reset all filter controls to their default values in the Plant Layout Window."""
    
        # **Reset Plant Name ComboBox**
        if self.plant_combo.count() > 0:
            self.plant_combo.setCurrentIndex(0)
        
        if self.section_combo.count() > 0:
            self.section_combo.setCurrentIndex(0)
            
        if self.line_combo.count() > 0:
            self.line_combo.setCurrentIndex(0)
    
        if self.station_combo.count() > 0:
            self.station_combo.setCurrentIndex(0)
            
        # **Reset Shift ComboBox**
        if self.shift_combo.count() > 1:
            self.shift_combo.setCurrentIndex(1)
    
        # **Reset Tool ComboBox (Default: LiFFT)**
        index = self.tool_combo.findText("LiFFT")
        if index != -1:
            self.tool_combo.setCurrentIndex(index)
    
        # **Reset Gender ComboBox (Default: Both)**
        if self.gender_combo.count() > 0:
            self.gender_combo.setCurrentIndex(0)  # Assuming "Both" is at index 0
    
        # **Clear Age, Weight, and Height Inputs**
        self.agefrom_edit.clear()
        self.ageto_edit.clear()
        self.weightfrom_edit.clear()
        self.weightto_edit.clear()
        self.heightfrom_edit.clear()
        self.heightto_edit.clear()
    
        # **Uncheck Worker Filter Group**
        self.workerfilter_group.setChecked(False)    

    
    
    
    # Handlers for the buttons
    def orderInfoButtonClicked(self):
        self.setWorkerOrder()    
        
    
    def setWorkerOrder(self):
        #print("Is Numbered Order:", self.isNumberOrder)
        if not self.isNumberOrder:
            self.orderInfo_button.setIcon(QIcon("../images/numberorder01.png"))
            self.loadWorkers(1)
        else:
            self.orderInfo_button.setIcon(QIcon("../images/alphaorder01.png"))
            self.loadWorkers(0)
    
    
        selected_worker = self.workerComboBox.currentText().strip()
        # Extract worker ID (format: "<worker_id> (Last, First)")
        worker_id = selected_worker.split(" ")[0] if " " in selected_worker else selected_worker
        self.loadWorkerDetails(worker_id)
        self.updateWorkerBorders()
        
        self.isNumberOrder = not self.isNumberOrder  # Toggle the state

    
    
    
    
    
    
    def searchInfoWorkerClicked(self):
        """
        Search for a worker in the preloaded dataset and set the matching worker in the combo box.
        """
        # Ensure there is data loaded
        if not self.workerstationshifttool_dataset:
            QMessageBox.warning(self, "Error", "No workers available to search.")
            return 
    
        # Create the search dialog
        dialog = QDialog(self)
        dialog.setWindowTitle("Search Worker")
        dialog.setFixedSize(400, 200)
        layout = QVBoxLayout(dialog)

        # ID Search
        id_layout = QHBoxLayout()
        id_label = QLabel("Search by ID:")
        id_input = QLineEdit()
        id_layout.addWidget(id_label)
        id_layout.addWidget(id_input)
        layout.addLayout(id_layout)

        # Name Search
        name_layout = QHBoxLayout()
        name_label = QLabel("Search by Name:")
        first_name_input = QLineEdit()
        first_name_input.setPlaceholderText("First Name")
        last_name_input = QLineEdit()
        last_name_input.setPlaceholderText("Last Name")
        name_layout.addWidget(name_label)
        name_layout.addWidget(last_name_input)
        name_layout.addWidget(first_name_input)
        layout.addLayout(name_layout)

        # Dialog buttons
        button_box = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
        layout.addWidget(button_box)

        # **Search Logic (No DB Query)**
        def performSearch():
            worker_id = id_input.text().strip()
            first_name = first_name_input.text().strip()
            last_name = last_name_input.text().strip()
            
            matched_index = -1  # Store the index of the matching item
    
            for i, row in enumerate(self.workerstationshifttool_dataset):
                row_worker_id = row.get("worker_id", "").strip()
                row_first_name = row.get("first_name", "").strip()
                row_last_name = row.get("last_name", "").strip()
    
                # **Match by Worker ID**
                if worker_id and row_worker_id == worker_id:
                    matched_index = i
                    break  # Stop searching after finding a match
                
                # **Match by Full Name**
                if first_name and last_name:
                    if row_first_name.lower() == first_name.lower() and row_last_name.lower() == last_name.lower():
                        matched_index = i
                        break  # Stop searching after finding a match

            if matched_index != -1:
                self.workerComboBox.setCurrentIndex(matched_index)
            else:
                QMessageBox.warning(self, "Not Found", "Worker not found in the dataset.")
    
            dialog.accept()
    
        # Connect buttons to actions
        button_box.accepted.connect(performSearch)
        button_box.rejected.connect(dialog.reject)

        # Show the dialog
        dialog.exec_()

    
    
    
    def onPlotClicked(self, event):
        """Opens the expanded plot viewer when the plot is clicked."""
        if hasattr(self, "current_plot_figure") and self.current_plot_figure:
            dialog = PlotViewerDialog(self.current_plot_figure, self)
            dialog.exec_()  # Open dialog modally
            #self.openPlotWindow(self.current_plot_figure)   	
            
            
            
    def openPlotWindow(self, fig):
        """Show the interactive Matplotlib window with zoom, pan, and save options."""
        #fig.show()  # Display Matplotlib's interactive window
        plt.figure(fig.number)  # Associate the figure with pyplot
        plt.show()  # Display the interactive Matplotlib window
       	
    def onSummaryPlotChanged(self):
        """Handles summary plot selection and calls the corresponding function."""
        selected_index = self.summaryplot_combo.currentIndex()
    
        # **Ensure workers dataset is available**
        if not hasattr(self, "workerstationshifttool_dataset") or not self.workerstationshifttool_dataset:
            print("Error: No worker data available for plotting.")
            return
    
        enabled_workers = [worker for worker in self.workerstationshifttool_dataset if worker.get("enable", 0) == 1]
        
        enabled_workersAllTools = [worker for worker in self.workerstationshiftAlltools_dataset if worker.get("enable", 0) == 1]
            
        # **Call the appropriate function based on selection**
        if selected_index == 0:
            self.generateTotalWorkerRiskDistributionPlot(enabled_workersAllTools)
        elif selected_index == 1:
            self.generateWorkerRiskDistributionPlot(enabled_workersAllTools)
        elif selected_index == 2:
            self.generateWorkerRiskByAgePlot(enabled_workersAllTools)
        elif selected_index == 3:
            self.generateWorkerRiskHeatmap(enabled_workers)
        elif selected_index == 4:
            self.generateRiskHeatmap(enabled_workers)
        elif selected_index == 5:
            self.generateWorkerDistributionPlot(enabled_workersAllTools)
        elif selected_index == 6:
            self.generateRiskVsAgePlot(enabled_workers)
        elif selected_index == 7:
        
            self.generateCumulativeRiskOverTimePlot(enabled_workersAllTools)
   	
       	
    
    
    def grtool1ButtonClicked(self):
        self.loadSelectedPlantImage()
        
    def grtool2ButtonClicked(self):
        self.savePlantImage()    
 
    def grtool3ButtonClicked(self):
        self.fullSceneZoomMode = True
        self.plantlayout_image.setCursor(Qt.CrossCursor)
        #print("Full scene zoom mode activated. Click in the scene to zoom in.")    
        
    
    def grtool4ButtonClicked(self):
        """
        Zooms out the QGraphicsView by a factor of 1/1.5,
        but never below the 1:1 (identity) scale.
        """
        # Retrieve the current transformation matrix.
        current_transform = self.plantlayout_image.transform()
        # Assume uniform scaling: m11() gives the current scale factor in x (and m22() in y)
        current_scale = current_transform.m11()
        
        # Check if the current scale is greater than 1.0 (i.e. zoomed in)
        if current_scale > 1.0:
            # Calculate the factor to zoom out by.
            zoom_factor = 1/1.5  # approximately 0.6667
            
            # Compute what the new scale would be if we apply zoom_factor.
            proposed_scale = current_scale * zoom_factor
            
            # If the proposed scale is less than 1.0, adjust the factor so we get exactly 1.0.
            if proposed_scale < 1.0:
                # Calculate the exact factor needed to bring the scale to 1.0
                zoom_factor = 1.0 / current_scale
            
            # Apply the scaling transformation.
            self.plantlayout_image.scale(zoom_factor, zoom_factor)
     
     
    def grtool5ButtonClicked(self):
        self.fullSceneZoomMode = False
        #self.plantlayout_image.setCursor(Qt.CrossCursor)
        self.plantlayout_image.unsetCursor()
        #self.plantlayout_image.resetTransform()
        #self.plantlayout_image.setTransform(QTransform())
        self.applyfilterButtonClicked() # TODO: Temporary solution, it should not be necesary to re-apply all, but reset transformations are not properly working
        #print("Full scene zoom mode activated. Click in the scene to zoom in.")    
      
    def grtool6ButtonClicked(self):
        self.savePlantLayoutImage()
        
        
    def grtool7ButtonClicked(self):
        """
        Cycles through opacity levels for all non-background items:
        100% (opaque) → 85% → 60% → back to 100%.
        """
        # Define the opacity levels to cycle through.
        opacity_levels = [0.9, 0.80, 0.70, 1.0]
        
        # Initialize current_opacity_index if it doesn't exist.
        if not hasattr(self, 'current_opacity_index'):
            self.current_opacity_index = 0
    
        # Get the new opacity from the list.
        new_opacity = opacity_levels[self.current_opacity_index]
    
        # Update the index for next time, wrapping around.
        self.current_opacity_index = (self.current_opacity_index + 1) % len(opacity_levels)
        
        # Iterate over all items in the scene.
        for item in self.plantlayout_scene.items():
            # Check if the item is NOT the background (assuming your background is stored in self.pixmap_background_item)
            if item != self.pixmap_background_item:
                # Set the new opacity.
                item.setOpacity(new_opacity)

        
    
    
    def grtool8ButtonClicked(self):
        """
        Updates the index.html file with new worker data for visualization.
        - Reads index.html
        - Replaces the const data = { ... } section with fresh JSON from convert_workers_to_json()
        - Optionally creates a backup before modifying
        """
        if not hasattr(self, 'workerstationshifttool_dataset'):
            return
         
         
        if not self.workerstationshifttool_dataset:
            #print("No worker data available.")
            return
        
        # Get the current directory where the application is running
        app_dir = os.path.dirname(os.path.abspath(__file__))
        index_file_path = os.path.join(app_dir, "index.html")
        backup_file_path = os.path.join(app_dir, "index_back.html")
    
        # **Generate Updated JSON Data**
        new_json_data = self.convert_workers_to_json()
        
        if not new_json_data:
            print("Error: No worker data available to update index.html.")
            return
        
        # **Ensure the JSON string is properly formatted**
        json_str = json.dumps(json.loads(new_json_data), indent=2)
    
        try:
            # **Check if index.html exists**
            if not os.path.exists(index_file_path):
                print("Error: index.html not found.")
                return
    
            # **Read index.html content**
            with open(index_file_path, "r", encoding="utf-8") as file:
                html_content = file.read()
    
            # **Create a backup before modification**
            if not os.path.exists(backup_file_path):
                with open(backup_file_path, "w", encoding="utf-8") as backup_file:
                    backup_file.write(html_content)
                #print("Backup created: index_back.html")
    
            # **Find and replace the `const data = { ... };` section**
            pattern = re.compile(r"(const data = )\{.*?\};", re.DOTALL)
            updated_html = pattern.sub(f"\\1{json_str};", html_content)
    
            # **Write updated content back to index.html**
            with open(index_file_path, "w", encoding="utf-8") as file:
                file.write(updated_html)
    
            #print("index.html successfully updated with new worker data.")

            zcp_layout_view = ZCPWindow(self)
            zcp_layout_view.exec_()  # Show the dialog as modal
         
    
        except Exception as e:
            print(f"Error updating index.html: {e}")
        
        
        
    
    
                  
     
    

    def convert_workers_to_json(self):
        """
        Converts workerstationshifttool_dataset into a JSON-like hierarchical structure.
        The hierarchy is: Plant → Section → Line → Station → Workers.
        """
        if not self.workerstationshifttool_dataset:
            print("No worker data available.")
            return {}

        # Create the root structure with the single plant name
        plant_name = self.workerstationshifttool_dataset[0]["plant_name"]
        plant_node = {"name": f"Plant: {plant_name}", "children": []}
    
        # Helper dictionaries for structuring hierarchy
        sections_dict = {}
        lines_dict = {}
        stations_dict = {}
    
        for worker in self.workerstationshifttool_dataset:
            section_name = worker["section_name"]
            line_name = worker["line_name"]
            station_name = worker["station_id"]
            worker_id = worker["worker_id"]
            full_name = f"{worker['first_name']} {worker['last_name']}".strip()
            age = QDate.currentDate().year() - worker["year_of_birth"] if worker["year_of_birth"] else "N/A"
            cumulative_damage = f"{worker.get('total_cumulative_damage', 0.0000):.4%}"
            risk_probability = f"{worker.get('probability_outcome', 0.0):.1f}%"
            gender = worker["gender"].lower() if worker["gender"] else "unknown"
            shift = worker["shift_id"]
    
            # Get the color from the database
            color = worker.get("color", "#72ff00")  # Default to green if missing
    
            # Create worker entry
            worker_entry = {
                "name": worker_id,
                "value": 1,
                "color": color,  # Use color from the dataset
                "gender": gender,
                "meta": {
                    "fullName": full_name,
                    "age": age,
                    "section": section_name,
                    "line": line_name,
                    "station": station_name,
                    "shift": shift,
                    "cumulativeDamage": cumulative_damage,
                    "riskProbability": risk_probability,
                }
            }
    
            # Organize hierarchy: Section → Line → Station → Workers
            if section_name not in sections_dict:
                sections_dict[section_name] = {"name": section_name, "children": []}
                plant_node["children"].append(sections_dict[section_name])
    
            if line_name not in lines_dict:
                lines_dict[line_name] = {"name": f"Line: {line_name}", "children": []}
                sections_dict[section_name]["children"].append(lines_dict[line_name])
    
            if station_name not in stations_dict:
                stations_dict[station_name] = {"name": f"Station: {station_name}", "children": []}
                lines_dict[line_name]["children"].append(stations_dict[station_name])
    
            # Append worker to respective station
            stations_dict[station_name]["children"].append(worker_entry)
    
        # Convert structure to JSON and print
        json_output = json.dumps(plant_node, indent=2)
        #print(json_output)
        return json_output
 
     
    def grtool9ButtonClicked(self):
        """
        Exports the data from self.workerstationshifttool_dataset to a CSV file.
        Validates if the dataset is available and not empty before proceeding.
        Uses a save dialog window with a suggested file name including the current date.
        Excludes unnecessary fields from the export.
        """
        # Check if the dataset is available and contains data
        if not hasattr(self, 'workerstationshifttool_dataset') or not self.workerstationshifttool_dataset:
            QMessageBox.warning(self, "No Data", "There is no data to export.")
            return
        
        # Suggested file name with the current date
        suggested_name = f"WorkerStationShiftData_{datetime.now().strftime('%Y-%m-%d')}.csv"
        
        # Open a save dialog to allow the user to choose the save location and file name
        file_path, _ = QFileDialog.getSaveFileName(
            self, 
            "Save Data as CSV", 
            suggested_name, 
            "CSV Files (*.csv);;All Files (*)"
        )
        
        # If the user cancels, file_path will be empty
        if not file_path:
            return
    
        # Fields to exclude from export
        excluded_fields = [
            'result_3', 'result_4', 'result_5', 'result_6', 'result_7', 'result_8', 'result_9',
            'x', 'y', 'width', 'ws_height', 'line_thickness', 'scale_x', 'scale_y',
            'crop_x', 'crop_y', 'crop_width', 'crop_height', 'zoom', 'rotation',
            'mirror_h', 'mirror_v', 'orientation', 'color', 'r', 'g', 'b',
            'brightness', 'contrast', 'saturation', 'lock', 'visible', 'transparency', 'enable'
        ]
    
        try:
            # Write data to CSV file excluding the specified fields
            with open(file_path, mode='w', newline='', encoding='utf-8') as file:
                # Get all field names and exclude the unwanted ones
                fieldnames = [key for key in self.workerstationshifttool_dataset[0].keys() if key not in excluded_fields]
                
                writer = csv.DictWriter(file, fieldnames=fieldnames)
                writer.writeheader()
            
                for row in self.workerstationshifttool_dataset:
                    # Create a filtered row excluding the unwanted fields
                    filtered_row = {key: value for key, value in row.items() if key in fieldnames}
                    writer.writerow(filtered_row)
            
            QMessageBox.information(self, "Success", f"Data successfully exported to:\n{file_path}")
        
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to export data:\n{str(e)}")
        
    
    def eventFilter(self, obj, event):
        """
        Event filter to intercept mouse events in the QGraphicsView's viewport.
        - Updates x/y values in xinfocurrent_input and yinfocurrent_input on mouse move.
        - Implements zoom functionality on mouse click when fullSceneZoomMode is active.
        """
        if obj is self.plantlayout_image.viewport():
            # **Handle Mouse Movement (Update x/y Info)**
            #if event.type() == QtCore.QEvent.MouseMove:
            #    scene_pos = self.plantlayout_image.mapToScene(event.pos())  # Convert to scene coordinates
            #        
            #    # Update input fields with current x/y position
            #    self.xview_input.setText(f"{scene_pos.x():.2f}")  # 2 decimal places
            #    self.yview_input.setText(f"{scene_pos.y():.2f}")
            #    return True  # Event handled.
   
            # **Handle Mouse Click (Zoom Functionality)**
            if event.type() == QtCore.QEvent.MouseButtonPress and self.fullSceneZoomMode:
                # When in zoom mode, use the click location as the zoom center.
                self.plantlayout_image.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
                
                # Apply the zoom transformation (example: zoom in by 50%).
                zoomFactor = 1.5
                self.plantlayout_image.scale(zoomFactor, zoomFactor)
                
                # Reset the anchor and mode.
                self.plantlayout_image.setTransformationAnchor(QGraphicsView.AnchorViewCenter)
                self.fullSceneZoomMode = False
                self.plantlayout_image.unsetCursor()
                return True  # Event handled.
    
        return super().eventFilter(obj, event)

        
    
    def savePlantLayoutImage(self):
        """
        Captures the current view of the plant layout (i.e. the QGraphicsView)
        and saves it as a PNG image.
        """
        # Build a default filename using the plant name and the current date/time.
        # Assumes you have a QComboBox named self.plant_combo with the plant name.
        plant_name = self.plant_combo.currentText()
        current_datetime = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        default_filename = f"{plant_name}_{current_datetime}.png"
    
        fileName, _ = QFileDialog.getSaveFileName(
            self, 
            "Save Plant Layout Image", 
            default_filename,  # Use the default filename here.
            "PNG Files (*.png);;All Files (*)"
        )
        
        # If the user cancels the dialog (i.e. fileName is empty), do nothing.
        if not fileName:
            return
        
        # Option 1: Use the QGraphicsView's grab() method to capture the viewport.
        # This returns a QPixmap of exactly what is visible (including the current scale,
        # transformations, and everything drawn in the view).
        pixmap = self.plantlayout_image.grab()
        
        # Option 2 (Alternative): You could also render the view explicitly if you need
        # more control over the rendering. For example:
        # rect = self.plantlayout_image.viewport().rect()
        # pixmap = QPixmap(rect.size())
        # pixmap.fill(Qt.transparent)  # Fill with a transparent background (if needed)
        # painter = QPainter(pixmap)
        # self.plantlayout_image.render(painter)
        # painter.end()
        
        # Save the captured pixmap to the selected file in PNG format.
        pixmap.save(fileName, "PNG")
    
            
    def workerComboIndexChanged(self):
        """
        Triggered when the workerComboBox index changes.
        Retrieves the selected worker's ID and loads the worker's details.
        """
        selected_worker = self.workerComboBox.currentText().strip()
    
        # Extract worker ID (format: "<worker_id> (Last, First)")
        worker_id = selected_worker.split(" ")[0] if " " in selected_worker else selected_worker
    
        # Call function to load details
        self.loadWorkerDetails(worker_id)
        
        self.updateWorkerBorders()
        

    
    def plantComboIndexChanged(self):
        self.editSectionName = self.section_combo.currentText().strip()
        self.loadSections()
        
        # TODO: more testing!!...it seems to work
        
        # **Restore the saved section into the combo box**
        index = self.section_combo.findText(self.editSectionName)  # Find index of saved value
        if index != -1:
            #self.section_combo.blockSignals(True)
            self.section_combo.setCurrentIndex(index)  # Restore selection
            #self.section_combo.blockSignals(False)
       
    
    #def sectionComboIndexChanged(self):
    #    self.editLineName = self.line_combo.currentText().strip()
    #    self.loadLines()
    #    index = self.line_combo.findText(self.editLineName)  # Find index of saved value
    #    if index != -1:
    #        #self.line_combo.blockSignals(True)
    #        self.line_combo.setCurrentIndex(index)  # Restore selection
    #        #self.line_combo.blockSignals(False)

    def sectionComboSelectionChanged(self):
        """
        Handles section combo selection changes, reloads lines, and restores previous selections.
        """
        # **Store Selected Line Items Before Refresh**
        #selected_lines = [
        #    self.line_combo.model().item(i).text()
        #    for i in range(self.line_combo.count())
        #    if self.line_combo.model().item(i).checkState() == Qt.Checked
        #]
        
        
        # **Check if Section Combo has any items selected, is empty, or has a blank value**
        if self.section_combo.count() == 0 or self.section_combo.lineEdit().text().strip() == "" or \
           all(self.section_combo.model().item(i).checkState() == Qt.Unchecked for i in range(self.section_combo.count())):
            self.line_combo.model().clear()  
            self.station_combo.model().clear()
            return  # Exit early if no sections are selected



        # **Reload Line Options**
        self.loadLines()

        # **Restore Previous Selections**
        #for i in range(self.line_combo.count()):
        #    item = self.line_combo.model().item(i)
        #    if item.text() in selected_lines:
        #        item.setCheckState(Qt.Checked)
        
        self.line_combo.updateText()
        
        if self.line_combo.count() > 0:
            first_item = self.line_combo.model().item(0)
            if first_item:
                first_item.setCheckState(Qt.Checked)  # Check the first item
            
            self.line_combo.lineEdit().setText("All") 
            if self.line_combo.lineEdit().text() == "All":
                for i in range(self.line_combo.count()):
                    self.line_combo.model().item(i).setCheckState(Qt.Checked)
                



        self.lineComboSelectionChanged()
        self.station_combo.updateText()
        
        
        
    #def lineComboIndexChanged(self):
    #    self.editStationID = self.station_combo.currentText().strip()
    #    self.loadStations()
    #    index = self.station_combo.findText(self.editStationID)  # Find index of saved value
    #    if index != -1:
    #        #self.station_combo.blockSignals(True)
    #        self.station_combo.setCurrentIndex(index)  # Restore selection
    #        #self.station_combo.blockSignals(False)

    
    def lineComboSelectionChanged(self):
        """Handles changes in the multi-selection Line combo and updates the Station combo accordingly."""
        
        # **Retrieve Previously Selected Stations**
        #previously_selected = [self.station_combo.model().item(i).text() 
        #                       for i in range(self.station_combo.count()) 
        #                       if self.station_combo.model().item(i).checkState() == Qt.Checked]
        
        
        # **Check if Line Combo has any items selected, is empty, or has a blank value**
        if self.line_combo.count() == 0 or self.line_combo.lineEdit().text().strip() == "" or \
           all(self.line_combo.model().item(i).checkState() == Qt.Unchecked for i in range(self.line_combo.count())):
            self.station_combo.model().clear()  # Properly clear MultiSelectComboBox
            return  # Exit early if no lines are selected

        
        # **Load New Stations Based on Updated Line Selection**
        self.loadStations()
    
        # **Restore Previous Selections**
        #for i in range(self.station_combo.count()):
        #    item = self.station_combo.model().item(i)
        #    if item.text() in previously_selected:
        #        item.setCheckState(Qt.Checked)  # Restore selection
        
        
        
        self.station_combo.updateText()
        #print("here?")
        #self.station_combo.lineEdit().setText("All")
        #print("self.station_combo.count():", self.station_combo.count())
        
        if self.station_combo.count() > 0:
            first_item = self.station_combo.model().item(0)
            if first_item:
                first_item.setCheckState(Qt.Checked)  # Check the first item
            
            self.station_combo.lineEdit().setText("All") 
            if self.station_combo.lineEdit().text() == "All":
                for i in range(self.station_combo.count()):
                    self.station_combo.model().item(i).setCheckState(Qt.Checked)
                



        
    
    def stationComboIndexChanged(self):
        return
        #print("Station combo changed:", self.station_combo.currentText())


    def saveAllInfoClicked(self):
        #"""Handles the click event for saveinfo_button (Dummy Function)."""
        #self.worker.saveData()
        #return
        self.saveAllVisualWorkers()
        
    
    

    def saveAllVisualWorkers(self):
        """Checks if visual_worker_tools exists and saves data for each worker tool."""
        
        # Ensure the list exists and is not empty
        if not hasattr(self, "visual_worker_tools") or not self.visual_worker_tools:
            return
    
        try:
            
            # Iterate through all worker tools and call their saveData function
            for worker_tool in self.visual_worker_tools:
                if hasattr(worker_tool, "saveData") and callable(worker_tool.saveData):
                    worker_tool.setScale(self.scaleallinfo_input.text().strip())
                    worker_tool.saveData()
                    worker_tool.initShape()
                
                    # Process pending events and wait briefly before next iteration
                    QApplication.processEvents()
                    #QTest.qWait(50)
            
            # If no errors occurred, show an information message.
            QMessageBox.information(self, "Success", "All visual worker tools saved successfully.")

        except Exception as e:
            # Show an error message if something goes wrong
            QMessageBox.critical(self, "Error", f"An error occurred while saving visual worker tools:\n{str(e)}")
        
        
    
    def saveInfoButtonClicked(self):
        self.saveVisualWorker()
        
    def saveVisualWorker(self):   
        # Ensure the list exists and is not empty
        if not hasattr(self, "visual_worker_tools") or not self.visual_worker_tools:
            return
    
        try:
            
            # **Get selected values from UI controls**
            selected_worker = self.workerComboBox.currentText().split(" ")[0]  # Extract Worker ID
            selected_plant = self.plantinfo.strip()
            selected_section = self.sectioninfo.strip()
            selected_line = self.lineinfo.strip()
            selected_station = self.stationinfo.strip()
            selected_shift = self.shiftinfo.strip()
            selected_tool = self.toolinfo.strip()
        
            # **Loop through workers 
            for worker_tool in self.visual_worker_tools:
                if (worker_tool.getWorkerID() == selected_worker and
                    worker_tool.getPlantName() == selected_plant and
                    worker_tool.getSectionName() == selected_section and
                    worker_tool.getLineName() == selected_line and
                    worker_tool.getStationID() == selected_station and
                    worker_tool.getShiftID() == selected_shift and
                    worker_tool.getToolID() == selected_tool):
                    
                    worker_tool.setX(self.xinfo_input.text().strip())
                    worker_tool.setY(self.yinfo_input.text().strip())
                    worker_tool.setScale(self.scaleinfo_input.text().strip())
                    worker_tool.saveDataAt()
                    #worker_tool.setBorder(True) 
                    worker_tool.initShapeAt()
                    #worker_tool.paintAt(self)
                    #worker_tool.setBorder(True)  
                    #worker_tool.update()
            
                    # Process pending events and wait briefly before next iteration
                    #QApplication.processEvents()
                    #QTest.qWait(50)
            
            # If no errors occurred, show an information message.
            QMessageBox.information(self, "Success", "Visual worker tool saved successfully.")

        except Exception as e:
            # Show an error message if something goes wrong
            QMessageBox.critical(self, "Error", f"An error occurred while saving visual worker tools:\n{str(e)}")
        
    
    
        
        
    def loadImageSimple(self, file_path):
        pixmap = QPixmap(file_path)
        self.plantlayout_scene.addPixmap(pixmap)
        self.plantlayout_image.fitInView(self.plantlayout_scene.sceneRect(), Qt.KeepAspectRatio)



    def loadImage(self, file_path, scene, image, scalex_factor, scaley_factor):
        pixmap = QPixmap(file_path)
        if pixmap.isNull():
            print(f"Failed to load the image: {file_path}")
            return

        scene.clear()  # Clear any previous content
        pixmap_item = scene.addPixmap(pixmap)  # Add the pixmap to the scene
        image.setScene(scene)

        # Calculate scaling factors
        #view_size = self.plantlayout_image.viewport().size()
        view_size = image.geometry().size()


        pixmap_size = pixmap.size()

        scale_x = view_size.width() / pixmap_size.width()
        scale_y = view_size.height() / pixmap_size.height()
        
        # Use the smaller scale for width and double it for height
        scale_factor_x = scale_x * scalex_factor
        scale_factor_y = scale_y * scaley_factor  # Double the scale for Y-axis

        # Apply the scaling
        image.resetTransform()  # Reset any existing transformations
        image.scale(scale_factor_x, scale_factor_y)

        # Center the image
        image.setAlignment(Qt.AlignCenter)

        # Optional: Hide scrollbars for a clean look
        #image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        #image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)


    def loadImageNew02(self, file_path, scene, image):
        pixmap = QPixmap(file_path)
        if pixmap.isNull():
            print(f"Failed to load the image: {file_path}")
            return
    
        scene.clear()  # Clear any previous content
        pixmap_item = scene.addPixmap(pixmap)  # Add the pixmap to the scene
        image.setScene(scene)
    
        # **Get the fixed size of the QGraphicsView (viewport to exclude borders)**
        view_width = image.viewport().width()
        view_height = image.viewport().height()
    
        # **Get the size of the pixmap**
        pixmap_width = pixmap.width()
        pixmap_height = pixmap.height()
    
        # **Calculate the best scale factor**
        scale_x = view_width / pixmap_width
        scale_y = view_height / pixmap_height
        scale_factor = min(scale_x, scale_y)  # Ensure the image fits without overflow
    
        # **Apply scaling**
        image.resetTransform()  # Reset transformations
        image.scale(scale_factor, scale_factor)
    
        # **Set a fixed scene size that matches the QGraphicsView**
        scene.setSceneRect(0, 0, view_width, view_height)
    
        # **Center the image manually**
        pixmap_item.setPos((view_width - (pixmap_width * scale_factor)) / 2,
                           (view_height - (pixmap_height * scale_factor)) / 2)
    
        # **Ensure no scrollbars appear**
        image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    
    
        # **Center the image**
        #image.setAlignment(Qt.AlignCenter)
        #scene.setAlignment(Qt.AlignCenter)
        
        # **Move scrollbars to zero if they appear (extra safety)**
        if image.horizontalScrollBar().isVisible():
            image.horizontalScrollBar().setValue(0)
        if image.verticalScrollBar().isVisible():
            image.verticalScrollBar().setValue(0)


    
    def loadImageNew(self, file_path, scene, image):
        pixmap = QPixmap(file_path)
        if pixmap.isNull():
            print(f"Failed to load the image: {file_path}")
            return

        scene.clear()  # Remove previous content
        self.pixmap_background_item = scene.addPixmap(pixmap)  # Add the pixmap to the scene
        image.setScene(scene)

        # Use the viewport's dimensions (the actual drawing area) rather than the widget’s full size.
        view_width = image.viewport().width()
        view_height = image.viewport().height()
        
        
        # **Get the size of the pixmap**
        pixmap_width = pixmap.width()
        pixmap_height = pixmap.height()
    
        # **Calculate the best scale factor**
        scale_x = view_width / pixmap_width
        scale_y = view_height / pixmap_height
        self.scale_factor = min(scale_x, scale_y)  # Ensure the image fits without overflow
    
        self.scale_factor = round(self.scale_factor, 2)
        
        #print("Scale Factor:", self.scale_factor)

        # Set the scene rectangle to match the available view area.
        scene.setSceneRect(0, 0, view_width, view_height)

        # Automatically scale and center the pixmap item.
        image.fitInView(self.pixmap_background_item, Qt.KeepAspectRatio)

        self.pixmap_background_item.setZValue(-1) # TODO: check if it helps...
        
        image.setAlignment(Qt.AlignTop | Qt.AlignLeft)
        #image.setAlignment(Qt.AlignCenter)
        #image.setAlignment(Qt.AlignCenter | Qt.AlignLeft)
        #image.setAlignment(Qt.AlignLeft)
        
        #image.setAlignment(Qt.AlignTop) # TODO: play with the alignments....FIX!!! https://qtcentre.org/threads/70174-How-to-properly-show-image-in-QGraphicsView
        #image.setAlignment(Qt.AlignCenter)
        
        # Disable scrollbars.
        image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)



    
    def loadImageNewWORKING(self, file_path, scene, image):
        pixmap = QPixmap(file_path)
        if pixmap.isNull():
            print(f"Failed to load the image: {file_path}")
            return
    
        scene.clear()  # Clear any previous content
        pixmap_item = scene.addPixmap(pixmap)  # Add the pixmap to the scene
        image.setScene(scene)
    
        # **Get the fixed size of the QGraphicsView (viewport to exclude borders)**
        #view_width = image.viewport().width()
        #view_height = image.viewport().height()
        
        # **Get the fixed size of the QGraphicsView**
        view_width = image.width()
        view_height = image.height()
    
        # **Get the size of the pixmap**
        pixmap_width = pixmap.width()
        pixmap_height = pixmap.height()
    
        # **Calculate the best scale factor**
        scale_x = view_width / pixmap_width
        scale_y = view_height / pixmap_height
        self.scale_factor = min(scale_x, scale_y)  # Ensure the image fits without overflow
    
        self.scale_factor = round(self.scale_factor, 2)
        # **Apply scaling**
        image.resetTransform()  # Reset transformations
        image.scale(self.scale_factor, self.scale_factor)
    
    
        # **Set a fixed scene size that matches the QGraphicsView**
        #scene.setSceneRect(0, 0, view_width, view_height)
    
        # **Center the image manually**
        #pixmap_item.setPos((view_width - (pixmap_width * self.scale_factor)) / 2,
        #                   (view_height - (pixmap_height * self.scale_factor)) / 2)
    
    
        
        #print("scale_factor:", self.scale_factor)
        
        # **Center the image**
        image.setAlignment(Qt.AlignCenter)
        
        #self.plantlayout_scene.setSceneRect(0, 0, 970, 580)  # Match the QGraphicsView size
     
        # **Ensure no scrollbars appear**
        image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    
        # **Move scrollbars to zero if they appear (extra safety)**
        if image.horizontalScrollBar().isVisible():
            image.horizontalScrollBar().setValue(0)
    
        if image.verticalScrollBar().isVisible():
            image.verticalScrollBar().setValue(0)
            
            
            
    def findVisualWorkerTool(self):
        """Finds the corresponding VisualWorkerTool object based on UI selections."""
        worker_id = self.workerComboBox.currentText().split(" ")[0]  # Extract Worker ID
        plant_name = self.plantinfo_label.text().strip()
        section_name = self.sectioninfo_label.text().strip()
        line_name = self.lineinfo_label.text().strip()
        station_id = self.stationinfo_label.text().strip()
        shift_id = self.shiftinfo_label.text().strip()
        tool_id = self.toolinfo_label.text().strip()
    
        # Search for the matching worker tool object
        for worker_tool in self.visual_worker_tools:
            if (worker_tool.getWorkerID() == worker_id and
                worker_tool.getPlantName() == plant_name and
                worker_tool.getSectionName() == section_name and
                worker_tool.getLineName() == line_name and
                worker_tool.getStationID() == station_id and
                worker_tool.getShiftID() == shift_id and
                worker_tool.getToolID() == tool_id):
                return worker_tool  # Return the matching object
    
        return None  # Return None if no match is found

    def visibleCheckChanged(self, state):
        if not hasattr(self, 'visual_worker_tools'):
            return
            
        """Handles changes to the visibility checkbox."""
        worker_tool = self.findVisualWorkerTool()
        if worker_tool:
            worker_tool.setVisible(state == Qt.Checked)
    
    def enableCheckChanged(self, state):
        if not hasattr(self, 'visual_worker_tools'):
            return
        """Handles changes to the enable checkbox."""
        worker_tool = self.findVisualWorkerTool()
        if worker_tool:
            worker_tool.setEnable(state == Qt.Checked)

    def lockCheckChanged(self, state):
        if not hasattr(self, 'visual_worker_tools'):
            return
        """Handles changes to the lock checkbox."""
        worker_tool = self.findVisualWorkerTool()
        if worker_tool:
            worker_tool.setLock(state == Qt.Checked)
            


   


    def loadWorkers(self, order_by):
        """
        Loads workers into the workerComboBox based on selected plant, section, line, station, and shift filters.
        """
        # Get the filtered workers list
        self.workerstationshifttool_dataset = self.getWorkers(order_by)
        self.workerstationshiftAlltools_dataset = self.getWorkersAllTools(order_by)
    
        # Suspend signals to prevent unwanted events
        self.workerComboBox.blockSignals(True)
        
        # Clear and populate the combobox
        self.workerComboBox.clear()
        #self.workerComboBox.addItems([
        #    f"{row['worker_id']} ({row['last_name']}, {row['first_name']})" if row['last_name'] and row['first_name']
        #    else row['worker_id']
        #    for row in self.workerstationshifttool_dataset
        #])
        
        # **Populate ComboBox with Formatted Entries**
        self.workerComboBox.addItems([
            (f"{row['worker_id']} ({row['last_name']}, {row['first_name']}) | " 
             f"Section: {row['section_name']} → "
             f"Line: {row['line_name']} → "
             f"Station: {row['station_id']} | "
             f"Shift: {row['shift_id']}")
            if row['last_name'] and row['first_name']
            else
            (f"{row['worker_id']} | "
             f"Section: {row['section_name']} → "
             f"Line: {row['line_name']} → "
             f"Station: {row['station_id']} | "
             f"Shift: {row['shift_id']}")
            for row in self.workerstationshifttool_dataset
        ])
    
 
       


        # Restore signals
        self.workerComboBox.blockSignals(False)


    def getWorkers(self, order_by, tid=None):
        """
        Retrieves workers from WorkerStationShiftErgoTool with additional worker details.
    
        Returns:
            list: A list of dictionaries containing worker data.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
    
        # Determine the order column
        order_column = "ws.worker_id" if order_by == 0 else "w.last_name"
        
        # Base query (includes ALL fields from WorkerStationShiftErgoTool and Worker with distinct column names)
        query = """
            SELECT 
                ws.worker_id, ws.plant_name, ws.section_name, ws.line_name, ws.station_id, ws.shift_id, ws.tool_id,
                ws.total_cumulative_damage, ws.probability_outcome, 
                ws.result_3, ws.result_4, ws.result_5, ws.result_6, ws.result_7, ws.result_8, ws.result_9, unit,
                
                -- Visual elements (Aliased to avoid conflicts)
                ws.x, ws.y, ws.width, ws.height AS ws_height, ws.line_thickness, ws.scale_x, ws.scale_y,
                ws.crop_x, ws.crop_y, ws.crop_width, ws.crop_height, ws.zoom, ws.rotation,
                ws.mirror_h, ws.mirror_v, ws.orientation, ws.color, ws.r, ws.g, ws.b,
                ws.brightness, ws.contrast, ws.saturation, ws.lock, ws.visible, ws.transparency, ws.enable,
                
                -- Worker details (Aliased to avoid conflicts)
                w.first_name, w.last_name, w.year_of_birth, w.month_of_birth, w.day_of_birth, 
                w.gender, w.height AS worker_height, w.weight AS worker_weight

            FROM WorkerStationShiftErgoTool ws
            JOIN Worker w ON ws.worker_id = w.id
        """

        # Collect filters from comboboxes
        filters = []
        params = []    
        
        
        plant_name = self.plant_combo.currentText().strip()
        section_name = self.section_combo.currentText().strip()
        line_name = self.line_combo.currentText().strip()
        station_id = self.station_combo.currentText().strip()
        shift_id = self.shift_combo.currentText().strip()
        tool_id = self.tool_combo.currentText().strip()  # Include tool filter
    
        if tid:
            tool_id = tid
        
    
        #print(f"Plant: {self.plant_combo.currentText().strip()}, "
        #  f"Section: {self.section_combo.currentText().strip()}, "
        #  f"Line: {self.line_combo.currentText().strip()}, "
        #  f"Station: {self.station_combo.currentText().strip()}, "
        #  f"Shift: {self.shift_combo.currentText().strip()}, "
        #  f"Tool: {self.tool_combo.currentText().strip()}")


        if plant_name != "All":
            filters.append("ws.plant_name = ?")
            params.append(plant_name)
    
        #if section_name != "All":
        #    filters.append("ws.section_name = ?")
        #    params.append(section_name)
        selected_sections = [self.section_combo.itemText(i) for i in range(self.section_combo.count())
                             if self.section_combo.model().item(i).checkState() == Qt.Checked and self.section_combo.itemText(i) != "All"]

        if selected_sections:
            # If multiple sections are selected, use the IN clause
            placeholders = ", ".join(["?"] * len(selected_sections))
            filters.append(f"ws.section_name IN ({placeholders})")
            params.extend(selected_sections)
        elif section_name != "All":
            # If a single section is selected
            filters.append("ws.section_name = ?")
            params.append(section_name)
    
            
            
        #if line_name != "All":
        #    filters.append("ws.line_name = ?")
        #    params.append(line_name)
        selected_lines = [self.line_combo.itemText(i) for i in range(self.line_combo.count())
                          if self.line_combo.model().item(i).checkState() == Qt.Checked and self.line_combo.itemText(i) != "All"]

        if selected_lines:
            # If multiple lines are selected, use the IN clause
            placeholders = ", ".join(["?"] * len(selected_lines))
            filters.append(f"ws.line_name IN ({placeholders})")
            params.extend(selected_lines)
        elif line_name != "All":
            # If a single line is selected
            filters.append("ws.line_name = ?")
            params.append(line_name)
    
    
        #if station_id != "All":
        #    filters.append("ws.station_id = ?")
        #    params.append(station_id)
            
        # **Station Filter Handling (Multi-Selection)**
        selected_stations = [self.station_combo.itemText(i) for i in range(self.station_combo.count())
                             if self.station_combo.model().item(i).checkState() == Qt.Checked and self.station_combo.itemText(i) != "All"]

        if selected_stations:
            # If multiple stations are selected, use the IN clause
            placeholders = ", ".join(["?"] * len(selected_stations))
            filters.append(f"ws.station_id IN ({placeholders})")
            params.extend(selected_stations)
        elif station_id != "All":
            # If a single station is selected
            filters.append("ws.station_id = ?")
            params.append(station_id)
        
            
    
        if shift_id != "All":
            filters.append("ws.shift_id = ?")
            params.append(shift_id)
    
        if tool_id != "All":
            filters.append("ws.tool_id = ?")
            params.append(tool_id)
        
        # **Apply Gender Filter (Only if Worker Filter Group is Checked OR Gender ComboBox is Enabled)**
        if self.workerfilter_group.isChecked() and self.gender_combo.isEnabled():
            selected_gender = self.gender_combo.currentText().strip()
            if selected_gender in ["Male", "Female"]:  # Ensure only valid selections (ignore "Both")
                filters.append("w.gender = ?")
                params.append(selected_gender)
            
        
        # **Apply Numeric Filters (Age, Weight, Height)**
        if self.workerfilter_group.isChecked():
            try:
                # **AGE FILTER**
                age_from = self.agefrom_edit.text().strip()
                age_to = self.ageto_edit.text().strip()
    
                if age_from.isdigit() and age_to.isdigit():
                    age_from = int(age_from)
                    age_to = int(age_to)
    
                    if age_from <= age_to:
                        current_year = QDate.currentDate().year()
                        min_year_of_birth = current_year - age_to  # Calculate min birth year
                        max_year_of_birth = current_year - age_from  # Calculate max birth year
    
                        filters.append("w.year_of_birth BETWEEN ? AND ?")
                        params.extend([min_year_of_birth, max_year_of_birth])
    
                # **WEIGHT FILTER**
                weight_from = self.weightfrom_edit.text().strip()
                weight_to = self.weightto_edit.text().strip()
    
                if weight_from.isdigit() and weight_to.isdigit():
                    weight_from = int(weight_from)
                    weight_to = int(weight_to)
    
                    if weight_from <= weight_to:
                        filters.append("worker_weight BETWEEN ? AND ?")
                        params.extend([weight_from, weight_to])
    
                # **HEIGHT FILTER**
                height_from = self.heightfrom_edit.text().strip()
                height_to = self.heightto_edit.text().strip()
    
                if height_from.isdigit() and height_to.isdigit():
                    height_from = int(height_from)
                    height_to = int(height_to)
    
                    if height_from <= height_to:
                        filters.append("worker_height BETWEEN ? AND ?")
                        params.extend([height_from, height_to])

            except ValueError:
                pass  # Ignore invalid numerical inputs
        
        
        
        # Append filters to query if necessary
        if filters:
            query += " WHERE " + " AND ".join(filters)
    
        query += f" ORDER BY {order_column}"
        #query += " ORDER BY ws.worker_id"
    
        try:
            # Connect to database and execute query
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Allow dictionary-like access
            cursor = conn.cursor()
            cursor.execute(query, params)
            workers = cursor.fetchall()
            conn.close()

            #for row in workers:
            #    print(row) 
            
            # Convert results to a list of dictionaries
            return [dict(row) for row in workers]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve workers:\n{str(e)}")
            return []
    

    def getWorkersAllTools(self, order_by):
        return self.getWorkers(order_by, "All")
        
    
    
    def loadWorkerDetails(self, workerid):
        """
        Loads worker details from the cached dataset (workerstationshifttool_dataset)
        into the respective UI controls.
        
        Args:
            workerid (str): The worker ID to search for.
        """
        
        
        
        # Ensure dataset is available
        if not hasattr(self, "workerstationshifttool_dataset") or not self.workerstationshifttool_dataset:
            QMessageBox.warning(self, "Error", "No worker data loaded.")
            return
        
        
        
        # Search for the worker's details in the dataset
        #worker_data = next((row for row in self.workerstationshifttool_dataset if row["worker_id"] == workerid), None)
        # **Retrieve worker data based on ComboBox index**
        worker_data = self.workerstationshifttool_dataset[self.workerComboBox.currentIndex()]

        if not worker_data:
            QMessageBox.warning(self, "Error", f"Worker ID {workerid} not found in dataset.")
            return
    
        
        # Calculate age
        current_year = QDate.currentDate().year()
        birth_year = worker_data.get("year_of_birth", 0)
        age = current_year - birth_year if birth_year else "N/A"
    
        
        # Debugging prints
        #print(f"Worker Data: {worker_data}")  # Check full dataset
        #print(f"Worker Height: {worker_data.get('worker_height')}")  # Correct worker height
        #print(f"WS Height: {worker_data.get('ws_height')}")  # Height from WorkerStationShiftErgoTool

        #print(f"Enable (Processed Value): {int(worker_data.get('enable', 0)) == 1}")  # Check conversion

        
        # Update UI Controls
        self.ageinfo_label.setText(str(age))
        self.sexinfo_label.setText(worker_data.get("gender", "N/A"))
        self.weightinfo_label.setText(f"{worker_data.get('worker_weight', 'N/A')}")
        self.heightinfo_label.setText(f"{worker_data.get('worker_height', 'N/A')}")
        
        
        self.plantinfo = f"{worker_data.get('plant_name', 'N/A')}"
        self.sectioninfo = f"{worker_data.get('section_name', 'N/A')}"
        self.lineinfo = f"{worker_data.get('line_name', 'N/A')}"
        self.stationinfo = f"{worker_data.get('station_id', 'N/A')}"
        self.shiftinfo = f"{worker_data.get('shift_id', 'N/A')}"
        self.toolinfo = f"{worker_data.get('tool_id', 'N/A')}"

        self.xinfo_input.setText(f"{int(worker_data.get('x', 0))}")
        self.yinfo_input.setText(f"{int(worker_data.get('y', 0))}")
        self.scaleinfo_input.setText(f"{float(worker_data.get('scale_x', 1.0)):.2f}") # Same scale both axes...

        # Set checkboxes (defaulting to unchecked if missing)
        self.visibleinfo_check.setChecked(worker_data.get("visible", 0) == 1)
        self.enableinfo_check.setChecked(worker_data.get("enable", 0) == 1)
        self.lockinfo_check.setChecked(worker_data.get("lock", 0) == 1)
        
        #self.enableinfo_check.setChecked(True)
        
        #print("Here3")
        
        
        
        
    def loadWorkerDetailsW(self, workerid):
        """
        Loads worker details from the cached dataset (workerstationshifttool_dataset)
        into the respective UI controls.
        
        Args:
            workerid (str): The worker ID to search for.
        """
        
        
        
        # Ensure dataset is available
        if not hasattr(self, "workerstationshifttool_dataset") or not self.workerstationshifttool_dataset:
            QMessageBox.warning(self, "Error", "No worker data loaded.")
            return
        
        
        
        # Search for the worker's details in the dataset
        #worker_data = next((row for row in self.workerstationshifttool_dataset if row["worker_id"] == workerid), None)
        # **Retrieve worker data based on ComboBox index**
        worker_data = self.workerstationshifttool_dataset[self.workerComboBox.currentIndex()]

        if not worker_data:
            QMessageBox.warning(self, "Error", f"Worker ID {workerid} not found in dataset.")
            return
    
        
        # Calculate age
        current_year = QDate.currentDate().year()
        birth_year = worker_data.get("year_of_birth", 0)
        age = current_year - birth_year if birth_year else "N/A"
    
        
        # Debugging prints
        #print(f"Worker Data: {worker_data}")  # Check full dataset
        #print(f"Worker Height: {worker_data.get('worker_height')}")  # Correct worker height
        #print(f"WS Height: {worker_data.get('ws_height')}")  # Height from WorkerStationShiftErgoTool

        #print(f"Enable (Processed Value): {int(worker_data.get('enable', 0)) == 1}")  # Check conversion

        
        # Update UI Controls
        self.ageinfo_label.setText(str(age))
        self.sexinfo_label.setText(worker_data.get("gender", "N/A"))
        self.weightinfo_label.setText(f"{worker_data.get('worker_weight', 'N/A')}")
        self.heightinfo_label.setText(f"{worker_data.get('worker_height', 'N/A')}")
        
        self.xinfo_label.setText(f"{int(worker_data.get('x', 0))}")
        self.yinfo_label.setText(f"{int(worker_data.get('y', 0))}")

        self.plantinfo_label.setText(f"{worker_data.get('plant_name', 'N/A')}")
        self.sectioninfo_label.setText(f"{worker_data.get('section_name', 'N/A')}")
        self.lineinfo_label.setText(f"{worker_data.get('line_name', 'N/A')}")
        self.stationinfo_label.setText(f"{worker_data.get('station_id', 'N/A')}")
        self.shiftinfo_label.setText(f"{worker_data.get('shift_id', 'N/A')}")
        self.toolinfo_label.setText(f"{worker_data.get('tool_id', 'N/A')}")

        #self.xinfo_label.setText(f"{int(worker_data.get('x', 0))}")
        #self.xinfo_label.setText(f"{int(worker_data.get('y', 0))}")
    
        # Set checkboxes (defaulting to unchecked if missing)
        self.visibleinfo_check.setChecked(worker_data.get("visible", 0) == 1)
        self.enableinfo_check.setChecked(worker_data.get("enable", 0) == 1)
        self.lockinfo_check.setChecked(worker_data.get("lock", 0) == 1)
        
        #self.enableinfo_check.setChecked(True)
        
        #print("Here3")
    
    
    def selectWorkerInComboBox(self, worker_obj):
        """Finds and selects the worker in workerComboBox based on the VisualWorkerTool instance."""
    
        if not self.workerstationshifttool_dataset or not hasattr(self, 'workerComboBox'):
            return  # Exit if dataset is empty or workerComboBox is missing
    
        # **Extract identifying fields from the worker object**
        worker_id = worker_obj.worker_id
        plant_name = worker_obj.plant_name
        section_name = worker_obj.section_name
        line_name = worker_obj.line_name
        station_id = worker_obj.station_id
        shift_id = worker_obj.shift_id
        tool_id = worker_obj.tool_id
    
        # **Find the correct index in the dataset**
        index = next(
            (i for i, row in enumerate(self.workerstationshifttool_dataset)
                 if row["worker_id"] == worker_id
                     and row["plant_name"] == plant_name
                     and row["section_name"] == section_name
                     and row["line_name"] == line_name
                     and row["station_id"] == station_id
                     and row["shift_id"] == shift_id
                     and row["tool_id"] == tool_id),
                -1  # Default to -1 if not found
            )

        # **Update the ComboBox Selection**
        if index != -1:
            self.workerComboBox.setCurrentIndex(index)
            
        
        # **Set border to False for all other VisualWorkerTool objects**
        for worker in self.visual_worker_tools:
            if worker != worker_obj:
                worker.setBorder(False)


    def loadTools(self):
        """
        Loads all ergonomic tools into the tool_combo combobox.
        """
        # Retrieve the full dataset
        self.ergotool_dataset = self.getTools()
    
        # Suspend signals while updating the combobox
        self.tool_combo.blockSignals(True)
    
        # Clear existing items and populate the combobox with tool IDs
        self.tool_combo.clear()
        tool_ids = [row["id"] for row in self.ergotool_dataset]
        self.tool_combo.addItems(tool_ids)
    
        # Set "LiFFT" as the default selection if available
        if "LiFFT" in tool_ids:
            self.tool_combo.setCurrentText("LiFFT")
    
        # Restore signals
        self.tool_combo.blockSignals(False)
    
    
    def getTools(self):
        """
        Retrieves all records from the ErgoTool table.
    
        Returns:
            list: A list of dictionaries containing tool data.
        """
        if not self.parent().projectFileCreated or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        # Query to retrieve all tool records
        query = """
            SELECT id, name, description, authors
            FROM ErgoTool
            ORDER BY id
        """
    
        try:
            # Connect to the database and execute query
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
            cursor.execute(query)
            tools = cursor.fetchall()
            conn.close()
    
            # Convert results to a list of dictionaries
            return [dict(row) for row in tools]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve ergonomic tools:\n{str(e)}")
            return []


    def loadPlants(self):
        """
        Loads all plants into the plant_combo combobox.
        """
        # Retrieve the full dataset
        self.plant_dataset = self.getPlants()
    
        # Suspend signals while updating the combobox
        self.plant_combo.blockSignals(True)
    
        # Clear existing items and populate the combobox with plant names
        self.plant_combo.clear()
        plant_names = [row["name"] for row in self.plant_dataset]
        self.plant_combo.addItems(plant_names)
    
        # Set "Default" as the default selection if available
        #if "Default" in plant_names:
        #    self.plant_combo.setCurrentText("Default")
    
        # Restore signals
        self.plant_combo.blockSignals(False)



    def getPlants(self):
        """
        Retrieves all records from the Plant table for plants that exist in WorkerStationShiftErgoTool.
    
        Returns:
            list: A list of dictionaries containing full plant data, including visual elements.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
    
            # Step 1: Get distinct plant names from WorkerStationShiftErgoTool
            cursor.execute("SELECT DISTINCT plant_name FROM WorkerStationShiftErgoTool")
            plant_names = [row["plant_name"] for row in cursor.fetchall()]
    
            if not plant_names:
                conn.close()
                return []
    
            # Step 2: Fetch full plant details for those plants
            query = f"""
                SELECT * FROM Plant
                WHERE name IN ({','.join(['?'] * len(plant_names))})
                ORDER BY name
            """
            cursor.execute(query, plant_names)
            plants = cursor.fetchall()
            conn.close()
    
            # Convert results to a list of dictionaries
            return [dict(row) for row in plants]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve plants:\n{str(e)}")
            return []

    
    
    def loadSections(self):
        """
        Loads all distinct sections for the selected plant into the section_combo combobox.
        """
        # Retrieve the full dataset
        self.section_dataset = self.getSections()
    
        # Suspend signals while updating the combobox
        self.section_combo.blockSignals(True)
    
        # Clear existing items and populate the combobox with section names
        #self.section_combo.clear()
        self.section_combo.model().clear() 
        
        self.section_combo.addSelectableItem("All")
        
        
        section_names = [row["section_name"] for row in self.section_dataset]
        #self.section_combo.addItems(section_names)
        self.section_combo.addSelectableItems(section_names)

        all_item = self.section_combo.model().item(0)  # "All" is at index 0
        all_item.setCheckState(Qt.Checked)

        # Trigger the selection update logic
        self.section_combo.updateText()
        
        # Add "All" as the default option
        #self.section_combo.insertItem(0, "All")
        #self.section_combo.setCurrentText("All")
    
        # Restore signals
        self.section_combo.blockSignals(False)
    
    
    def getSections(self):
        """
        Retrieves all distinct section names for the selected plant from WorkerStationShiftErgoTool.
    
        Returns:
            list: A list of dictionaries containing section names.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        # Ensure a plant is selected
        selected_plant = self.plant_combo.currentText().strip()
        if not selected_plant or selected_plant == "All":
            return []
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
    
            # Fetch distinct sections for the selected plant
            query = """
                SELECT DISTINCT section_name 
                FROM WorkerStationShiftErgoTool    
                WHERE plant_name = ?
                ORDER BY section_name
            """
            cursor.execute(query, (selected_plant,))
            sections = cursor.fetchall()
            conn.close()
    
            # Convert results to a list of dictionaries
            return [dict(row) for row in sections]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve sections:\n{str(e)}")
            return []

    
    
    def loadLines(self):
        """
        Loads all distinct lines for the selected plant and section into the line_combo combobox.
        """
        # Retrieve the full dataset
        self.line_dataset = self.getLines()
    
        # Suspend signals while updating the combobox
        self.line_combo.blockSignals(True)
    
        
        
        # Clear existing items and populate the combobox with line names
        #self.line_combo.clear()
        self.line_combo.model().clear() 
        
        self.line_combo.addSelectableItem("All")
        
        line_names = [row["line_name"] for row in self.line_dataset]
        #self.line_combo.addItems(line_names)
        self.line_combo.addSelectableItems(line_names)


        all_item = self.line_combo.model().item(0)  # "All" is at index 0
        all_item.setCheckState(Qt.Checked)

        # Trigger the selection update logic
        self.line_combo.updateText()
        
        # Add "All" as the default option
        #self.line_combo.insertItem(0, "All")
        #self.line_combo.setCurrentText("All")
    
        # Restore signals
        self.line_combo.blockSignals(False)


    
    def getLines(self):
        """
        Retrieves all distinct line names for the selected plant and section(s) from WorkerStationShiftErgoTool.
    
        Returns:
            list: A list of dictionaries containing line names.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
        
        # **Retrieve Selected Plant**
        selected_plant = self.plant_combo.currentText().strip()
        
        # **Retrieve Checked Sections from MultiSelectComboBox**
        selected_sections = [
            self.section_combo.model().item(i).text()
            for i in range(self.section_combo.count())
            if self.section_combo.model().item(i).checkState() == Qt.Checked
        ]
    
        # **Remove "All" from selection and adjust filtering behavior**
        if "All" in selected_sections:
            selected_sections = []  # Do not filter by section (keep all)
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
    
            # **Build Query Based on Filters**
            query = "SELECT DISTINCT line_name FROM WorkerStationShiftErgoTool WHERE plant_name = ?"
            params = [selected_plant]
    
            # **Apply Section Filter (If Specific Sections Selected)**
            if selected_sections:
                placeholders = ", ".join("?" * len(selected_sections))
                query += f" AND section_name IN ({placeholders})"
                params.extend(selected_sections)
    
            query += " ORDER BY line_name"  # Order results
    
            cursor.execute(query, params)
            lines = cursor.fetchall()
            conn.close()
    
            # Convert results to a list of dictionaries
            return [dict(row) for row in lines]

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve lines:\n{str(e)}")
            return []



    def getLinesW(self):
        """
        Retrieves all distinct line names for the selected plant and section from WorkerStationShiftErgoTool.
    
        Returns:
            list: A list of dictionaries containing line names.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        # Ensure plant and section are selected
        selected_plant = self.plant_combo.currentText().strip()
        selected_section = self.section_combo.currentText().strip()
    
        if not selected_plant or selected_plant == "All" or not selected_section or selected_section == "All":
            return []
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()    
    
            # Fetch distinct lines for the selected plant and section
            query = """
                SELECT DISTINCT line_name 
                FROM WorkerStationShiftErgoTool
                WHERE plant_name = ? AND section_name = ?
                ORDER BY line_name
            """
            cursor.execute(query, (selected_plant, selected_section))
            lines = cursor.fetchall()
            conn.close()

            # Convert results to a list of dictionaries
            return [dict(row) for row in lines]

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve lines:\n{str(e)}")
            return []


    def loadStations(self):
        """
        Loads all distinct stations for the selected plant, section, and line into the station_combo combobox.
        """
        # Retrieve the full dataset
        self.station_dataset = self.getStations()
    
        # Suspend signals while updating the combobox
        self.station_combo.blockSignals(True)
    
    
        # Clear existing items and populate the combobox with station names
        #self.station_combo.clear()
        self.station_combo.model().clear() 
        
        self.station_combo.addSelectableItem("All")
        
        station_names = [row["station_id"] for row in self.station_dataset]
        #self.station_combo.addItems(station_names)
        self.station_combo.addSelectableItems(station_names)
        
        all_item = self.station_combo.model().item(0)  # "All" is at index 0
        all_item.setCheckState(Qt.Checked)

        # Trigger the selection update logic
        self.station_combo.updateText()

        # Add "All" as the default option
        #self.station_combo.insertItem(0, "All")
        #self.station_combo.setCurrentText("All")
    
        # Restore signals
        self.station_combo.blockSignals(False)


    def getStations(self):
        """
        Retrieves all distinct station IDs for the selected plant, sections, and lines 
        from WorkerStationShiftErgoTool.
    
        Returns:
            list: A list of dictionaries containing station IDs.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        # Ensure plant is selected (section and line can have multiple selections)
        selected_plant = self.plant_combo.currentText().strip()
        if not selected_plant or selected_plant == "All":
            return []

        # Retrieve checked items from section and line combos
        selected_sections = [self.section_combo.itemText(i) for i in range(self.section_combo.count())
                             if self.section_combo.model().item(i).checkState() == Qt.Checked]
        
        selected_lines = [self.line_combo.itemText(i) for i in range(self.line_combo.count())
                          if self.line_combo.model().item(i).checkState() == Qt.Checked]
    
        # **Ignore section/line filters if "All" is selected**
        use_section_filter = "All" not in selected_sections
        use_line_filter = "All" not in selected_lines
    
              
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
    
            # **Base Query**
            query = """
                SELECT DISTINCT station_id 
                FROM WorkerStationShiftErgoTool
                WHERE plant_name = ?
            """
            params = [selected_plant]

            # **Apply Section Filter (Only if "All" is NOT selected)**
            if use_section_filter and selected_sections:
                query += f" AND section_name IN ({', '.join(['?'] * len(selected_sections))})"
                params.extend(selected_sections)
    
            # **Apply Line Filter (Only if "All" is NOT selected)**
            if use_line_filter and selected_lines:
                query += f" AND line_name IN ({', '.join(['?'] * len(selected_lines))})"
                params.extend(selected_lines)
    
            # **Sorting**
            query += " ORDER BY station_id"
    
    
            # Print the query before execution (for debugging)
            #formatted_query = query.replace("?", "{}").format(*[repr(p) for p in params])
            #print(f"Executing SQL Query:\n{formatted_query}")


            # **Execute Query**
            cursor.execute(query, params)
            stations = cursor.fetchall()
            conn.close()

            # **Convert results to a list of dictionaries**
            return [dict(row) for row in stations]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve stations:\n{str(e)}")
            return []

    
    def getStationsW(self):
        """
        Retrieves all distinct station IDs for the selected plant, section, and line from WorkerStationShiftErgoTool.
    
        Returns:
            list: A list of dictionaries containing station IDs.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        # Ensure plant, section, and line are selected
        selected_plant = self.plant_combo.currentText().strip()
        selected_section = self.section_combo.currentText().strip()
        selected_line = self.line_combo.currentText().strip()
    
        if not selected_plant or selected_plant == "All" or not selected_section or selected_section == "All" or not selected_line or selected_line == "All":
            return []
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
    
            # Fetch distinct stations for the selected plant, section, and line
            query = """
                SELECT DISTINCT station_id 
                FROM WorkerStationShiftErgoTool
                WHERE plant_name = ? AND section_name = ? AND line_name = ?
                ORDER BY station_id
            """
            cursor.execute(query, (selected_plant, selected_section, selected_line))
            stations = cursor.fetchall()
            conn.close()
    
            # Convert results to a list of dictionaries
            return [dict(row) for row in stations]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve stations:\n{str(e)}")
            return []



    def loadShifts(self):
        """
        Loads distinct shift IDs into the shift_combo combobox.
        """
        # Retrieve the full dataset
        self.shift_dataset = self.getShifts()
    
        # Suspend signals while updating the combobox
        self.shift_combo.blockSignals(True)
    
        # Clear existing items
        #self.shift_combo.clear()
        self.shift_combo.model().clear() 
        
        self.shift_combo.addSelectableItem("All")
        
        # Add "All" as the first item
        #self.shift_combo.addItem("All")
    
        # Populate combobox with shift IDs from the dataset
        shift_ids = [row["id"] for row in self.shift_dataset]
        #self.shift_combo.addItems(shift_ids)
        self.shift_combo.addSelectableItems(shift_ids)
    
        # Set "1" as the default selection if available
        #if "1" in shift_ids:
        #    self.shift_combo.setCurrentText("1")
        # Check if the combo box has more than one item
        if self.shift_combo.count() > 1:
            second_item = self.shift_combo.model().item(1)  # Get the second item
            if second_item:
                second_item.setCheckState(Qt.Checked)  # Check the second item
                self.shift_combo.lineEdit().setText(second_item.text())  # Update combo box text
        
        
        
        # Trigger the selection update logic
        self.shift_combo.updateText()
        
         
        # Restore signals
        self.shift_combo.blockSignals(False)
    
    
    def getShifts(self):
        """
        Retrieves all records from the Shift table for shift IDs that exist in WorkerStationShiftErgoTool.
    
        Returns:
            list: A list of dictionaries containing full shift data.
        """
        # Ensure parent reference is valid and database path exists
        if not self.parent() or not hasattr(self.parent(), 'projectdatabasePath') or not self.parent().projectdatabasePath:
            QMessageBox.warning(self, "Error", "No project file loaded or saved.")
            return []
    
        try:
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            conn.row_factory = sqlite3.Row  # Dictionary-like access
            cursor = conn.cursor()
    
            # Step 1: Get distinct shift IDs from WorkerStationShiftErgoTool
            cursor.execute("SELECT DISTINCT shift_id FROM WorkerStationShiftErgoTool")
            shift_ids = [row["shift_id"] for row in cursor.fetchall()]
    
            if not shift_ids:
                conn.close()
                return []
    
            # Step 2: Fetch full shift details for those shifts
            query = f"""
                SELECT * FROM Shift
                WHERE id IN ({','.join(['?'] * len(shift_ids))})
                ORDER BY id
            """
            cursor.execute(query, shift_ids)
            shifts = cursor.fetchall()
            conn.close()
    
            # Convert results to a list of dictionaries
            return [dict(row) for row in shifts]
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to retrieve shifts:\n{str(e)}")
            return []
    
    
    # Load the open file dialog image into the image area
    def loadSelectedPlantImage(self):
        # TODO: check why it show a different type of dialog than open file!!!
        """
        Opens a file dialog to select an image and loads it into the plantlayout_image control
        without saving it to the project folder or updating the database.
        """
        # Open file dialog for selecting an image (JPG or PNG only)
        file_path, _ = QFileDialog.getOpenFileName(self, "Select Plant Image", "", "Images (*.png *.jpg)")
        
        if not file_path:
            return  # User canceled selection
    
        # Load the image into the UI without saving
        self.loadImage(file_path, self.plantlayout_scene, self.plantlayout_image, 0.9, 0.9)
    
        # Store the selected image path in a temporary variable for later saving
        self.temp_plant_image_path = file_path
    
        #QMessageBox.information(self, "Image Loaded", "The selected image has been loaded but not yet saved.")
   
    
    
    def loadVisualWorkerTools(self):
        """Creates VisualWorkerTool objects from the workerstationshifttool_dataset and stores them in a list."""
    
        # **Ensure the dataset is available**
        if not hasattr(self, 'workerstationshifttool_dataset'):
            print("Error: Worker dataset is not available.")
            return
    
        # **Clear previous visual tools (if any)**
        #if hasattr(self, 'visual_worker_tools'):
        #    for worker_tool in self.visual_worker_tools:
        #        if worker_tool in self.plantlayout_scene.items():
        #            print("Removing item from scene...")
        #            self.plantlayout_scene.removeItem(worker_tool)
        
        # **Clear only visible visual tools**
        if hasattr(self, 'visual_worker_tools'):
            for worker_tool in self.visual_worker_tools:
                if worker_tool in self.plantlayout_scene.items() and worker_tool.isVisible():
                    print("Removing item from scene...")
                    self.plantlayout_scene.removeItem(worker_tool)


        # **Initialize the list to store objects**
        self.visual_worker_tools = []
    
        # **Loop through each worker in the dataset and create a visual object**
        for worker_data in self.workerstationshifttool_dataset:
            worker_tool = VisualWorkerTool(self.plantlayout_scene, worker_data, self.scale_factor)  # Create the object
            self.visual_worker_tools.append(worker_tool)  # Store in the list
    
        print(f"Loaded {len(self.visual_worker_tools)} VisualWorkerTool objects.")

    
    def updateWorkerBorders(self):
        """Updates the border visibility for VisualWorkerTool objects, keeping only the selected one highlighted."""
    
        if not self.visual_worker_tools or not hasattr(self, 'workerComboBox'):
            return  # Exit if no workers are loaded or workerComboBox is missing
    
        # **Get selected values from UI controls**
        selected_worker = self.workerComboBox.currentText().split(" ")[0]  # Extract Worker ID
        selected_plant = self.plantinfo.strip()
        selected_section = self.sectioninfo.strip()
        selected_line = self.lineinfo.strip()
        selected_station = self.stationinfo.strip()
        selected_shift = self.shiftinfo.strip()
        selected_tool = self.toolinfo.strip()
        
       
    
        # **Loop through workers and set borders accordingly**
        for worker in self.visual_worker_tools:
            if (worker.getWorkerID() == selected_worker and
                worker.getPlantName() == selected_plant and
                worker.getSectionName() == selected_section and
                worker.getLineName() == selected_line and
                worker.getStationID() == selected_station and
                worker.getShiftID() == selected_shift and
                worker.getToolID() == selected_tool):
                worker.setBorder(True)  # Keep selected worker's border
            else:
                worker.setBorder(False)  # Deselect others


    
    def loadSummary(self):
        """Calculates and updates summary statistics from workerstationshifttool_dataset, considering only enabled workers."""
        
        if not hasattr(self, "workerstationshifttool_dataset") or not self.workerstationshifttool_dataset:
            print("Error: workerstationshifttool_dataset is empty or not available.")
            return

        # **Filter dataset to only include enabled workers**
        enabled_workers = [worker for worker in self.workerstationshifttool_dataset if worker.get("enable", 0) == 1]
        
        enabled_workersAllTools = [worker for worker in self.workerstationshiftAlltools_dataset if worker.get("enable", 0) == 1]
        
        #if not enabled_workers:
        #    print("Warning: No enabled workers found in dataset.")
        #    self.summaryresult1_label.setText("Total Workers: 0")
        #    self.summaryresult2_label.setText("Average Age: 0")
        #    self.summaryresult3_label.setText("Males: 0")
        #    self.summaryresult4_label.setText("Females: 0")
        #    self.summaryresult5_label.setText("Avg. Cumulative Damage: 0%")
        #    self.summaryresult6_label.setText("Risk Job: 0%")
        #    self.summaryresult7_label.setText("Avg. Job Risk: 0%")
        #    return
    
        # **Initialize Counters**
        total_workers = len(enabled_workers)
        total_age = 0
        male_count = 0
        female_count = 0
        total_cumulative_damage = 0
        total_risk_job = 0
        total_probability_outcome = 0
    
        # **Loop Through Enabled Workers**
        for worker in enabled_workers:
            age = 0
            if worker.get("year_of_birth"):
                age = QDate.currentDate().year() - worker["year_of_birth"]  # Calculate age
            total_age += age
    
            gender = worker.get("gender", "").strip().lower() if worker.get("gender") else "other"

            if gender == "male":
                male_count += 1
            elif gender == "female":
                female_count += 1
    
            total_cumulative_damage += worker.get("total_cumulative_damage", 0.0)
            total_risk_job += worker.get("probability_outcome", 0.0)  # Risk job is probability_outcome
            total_probability_outcome += worker.get("probability_outcome", 0.0)  # Avg. Job Risk

        # **Calculate Averages**
        avg_age = total_age / total_workers if total_workers > 0 else 0
        avg_cumulative_damage = (total_cumulative_damage / total_workers) if total_workers > 0 else 0
        #avg_cumulative_damage = round((total_cumulative_damage / total_workers), 4) if total_workers > 0 else 0.0000
        avg_job_risk = (total_probability_outcome / total_workers) if total_workers > 0 else 0
        risk_job = min(total_risk_job, 100)  # Assuming Risk Job is a maximum probability metric (bounded to 100%)
    
        # **Update UI Labels**
        self.summaryresult1_label.setText(f"<b>Total Workers:</b> {total_workers}")
        self.summaryresult2_label.setText(f"<b>Average Age:</b> {int(avg_age)}")
        self.summaryresult3_label.setText(f"<b>Males:</b> {male_count}")
        self.summaryresult4_label.setText(f"<b>Females:</b> {female_count}")
        self.summaryresult5_label.setText(f"<b>Avg. Cumulative Damage:</b> {avg_cumulative_damage:.4f}")
        self.summaryresult6_label.setText(f"<b>Risk Job:</b> {risk_job:.1f}%")
        self.summaryresult7_label.setText(f"<b>Avg. Job Risk:</b> {avg_job_risk:.1f}%")

        # **Generate and Display Risk Distribution Plot**
        #self.generateRiskDistributionPlot(enabled_workers)
        self.generateTotalWorkerRiskDistributionPlot(enabled_workersAllTools)
        #self.generateWorkerRiskHeatmap(enabled_workers)
        #self.generateRiskHeatmap(enabled_workers)
        #self.generateWorkerDistributionPlot(enabled_workers)
        #self.generateRiskVsAgePlot(enabled_workers)
        #self.generateCumulativeRiskOverTimePlot(enabled_workers)
    
    
    
    
    def generateWorkerRiskDistributionPlot(self, workers):
        """Generates a grouped bar chart for Worker Distribution by Gender & Tool with Avg. Risk and updates self.summaryplot_canvas."""
        
        if not workers:
            print("No enabled workers found for worker risk distribution plot.")
            return
    
        # **Initialize Risk Storage for Each Tool & Gender**
        gender_tool_risk = {
            "LiFFT": {"male": [], "female": []},
            "DUET": {"male": [], "female": []},
            "ST": {"male": [], "female": []}
        }

        # **Aggregate Data by Tool & Gender**
        for worker in workers:
            tool = worker.get("tool_id", "").strip()
            gender = worker.get("gender", "").strip().lower()
            risk = worker.get("probability_outcome", 0.0)  # Risk Percentage
        
            if tool in gender_tool_risk:
                if gender == "male":
                    gender_tool_risk[tool]["male"].append(risk)
                elif gender == "female":
                    gender_tool_risk[tool]["female"].append(risk)

        # **Compute Average Risk and Standard Deviation**
        tools = list(gender_tool_risk.keys())  # ["LiFFT", "DUET", "ST"]
    
        male_avg_risk = [np.mean(gender_tool_risk[tool]["male"]) if gender_tool_risk[tool]["male"] else 0 for tool in tools]
        female_avg_risk = [np.mean(gender_tool_risk[tool]["female"]) if gender_tool_risk[tool]["female"] else 0 for tool in tools]

        male_std_risk = [np.std(gender_tool_risk[tool]["male"]) if gender_tool_risk[tool]["male"] else 0 for tool in tools]
        female_std_risk = [np.std(gender_tool_risk[tool]["female"]) if gender_tool_risk[tool]["female"] else 0 for tool in tools]

        # **Set Scale Factor for Plot Size**
        scale_factor = 1.0  
    
        # **Set Bar Width & Positions**
        x = np.arange(len(tools))  # X locations for groups
        width = 0.3  # Bar width (adjusted for spacing)

        # **Create the Figure**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))

        # **Plot Bars with Error Bars**
        #bars1 = ax.bar(x - width/2, male_avg_risk, width, yerr=male_std_risk, label="Male", color="royalblue", alpha=0.75, capsize=3)
        #bars2 = ax.bar(x + width/2, female_avg_risk, width, yerr=female_std_risk, label="Female", color="lightcoral", alpha=0.75, capsize=3)

        bars1 = ax.bar(x - width/2, male_avg_risk, width, yerr=male_std_risk, 
               label="Male", color=cm.Set2(1), alpha=0.75, capsize=3)
        bars2 = ax.bar(x + width/2, female_avg_risk, width, yerr=female_std_risk, 
               label="Female", color=cm.Set2(2), alpha=0.75, capsize=3)


        # **Labels & Titles (Bold Font, Adjusted Sizes)**
        ax.set_xlabel("Tool Type", fontsize=8, fontweight="bold")
        ax.set_ylabel("Avg. Risk (%)", fontsize=8, fontweight="bold")
        ax.set_title("Worker Risk Distribution by Gender & Tool", fontsize=7, fontweight="bold")

        # **X-Ticks (Tool Labels)**
        ax.set_xticks(x)
        ax.set_xticklabels(tools, fontsize=7)
    
        # **Legend (Compact & Adjusted)**
        ax.legend(fontsize=7, loc="upper right", frameon=True)
        #ax.legend(fontsize=7, loc='upper center', bbox_to_anchor=(0.5, -0.35), ncol=2)

        
    
        # **Set Y-axis limit (0-100%)**
        ax.set_ylim(0, 100)
    
        # **Ensure Layout is Optimized**
        plt.tight_layout()
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  

        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()

    
    
    def generateTotalWorkerRiskDistributionPlot(self, workers):
        """Generates a bar chart for Total Worker Risk Distribution by Tool and updates self.summaryplot_canvas."""
        
        if not workers:
            print("No enabled workers found for worker risk distribution plot.")
            return
    
        # **Initialize Risk Storage for Each Tool**
        tool_risk = {
            "LiFFT": [],
            "DUET": [],
            "ST": []
        }

        # **Aggregate Risk Data by Tool**
        for worker in workers:
            tool = worker.get("tool_id", "").strip()
            risk = worker.get("probability_outcome", 0.0)  # Risk Percentage
    
            if tool in tool_risk:
                tool_risk[tool].append(risk)
    
        # **Compute Average Risk and Standard Deviation**
        tools = list(tool_risk.keys())  # ["LiFFT", "DUET", "ST"]
        
        avg_risk = [np.mean(tool_risk[tool]) if tool_risk[tool] else 0 for tool in tools]
        std_risk = [np.std(tool_risk[tool]) if tool_risk[tool] else 0 for tool in tools]
    
        # **Set Scale Factor for Plot Size**
        scale_factor = 1.0  
    
        # **Set Bar Width & Positions**
        x = np.arange(len(tools))  # X locations for bars
        width = 0.5  # Single bar width

        # **Create the Figure**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))
    
        colors = ["#4682B4", "#8B4513", "#9370DB"]
        # **Plot Bars with Error Bars**
        #bars = ax.bar(x, avg_risk, width, yerr=std_risk, 
        #              color=cm.Set2(2), alpha=0.75, capsize=3)
    
        bars = ax.bar(x, avg_risk, width, yerr=std_risk, 
                      color=colors, alpha=0.75, capsize=3)
                      
        # **Labels & Titles (Bold Font, Adjusted Sizes)**
        ax.set_xlabel("Tool Type", fontsize=8, fontweight="bold")
        ax.set_ylabel("Avg. Risk (%)", fontsize=8, fontweight="bold")
        ax.set_title("Total Worker Risk Distribution by Tool", fontsize=7, fontweight="bold")
    
        # **X-Ticks (Tool Labels)**
        ax.set_xticks(x)
        ax.set_xticklabels(tools, fontsize=7)
    
        # **Set Y-axis limit (0-100%)**
        ax.set_ylim(0, 100)
    
        # **Ensure Layout is Optimized**
        plt.tight_layout()
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()

    
    
    
    def generateWorkerRiskByAgePlot(self, workers):
        """Generates a grouped bar chart for Worker Risk Distribution by Age Range and Tool and updates self.summaryplot_canvas."""
        
        if not workers:
            print("No enabled workers found for worker risk distribution plot.")
            return
    
        current_year = QDate.currentDate().year()
    
        # **Initialize Risk Storage for Each Tool & Age Range**
        tool_age_risk = {
            "LiFFT": {},
            "DUET": {},
            "ST": {}
        }

        # **Determine Age Ranges from Data (Dynamic Binning)**
        all_ages = [current_year - worker["year_of_birth"] for worker in workers if worker.get("year_of_birth")]
        
        if not all_ages:
            print("No valid age data found.")
            return
    
        min_age, max_age = min(all_ages), max(all_ages)
        bin_size = 10  # Each range will span 10 years
        age_ranges = list(range((min_age // bin_size) * bin_size, (max_age // bin_size + 1) * bin_size, bin_size))
        
        # Initialize age groups in tool_age_risk
        for tool in tool_age_risk:
            for start_age in age_ranges:
                tool_age_risk[tool][f"{start_age}-{start_age + bin_size - 1}"] = []
    
        # **Aggregate Risk Data by Tool & Age Range**
        for worker in workers:
            tool = worker.get("tool_id", "").strip()
            age = current_year - worker.get("year_of_birth", 0)
            risk = worker.get("probability_outcome", 0.0)  # Risk Percentage
    
            if tool in tool_age_risk:
                for start_age in age_ranges:
                    if start_age <= age < start_age + bin_size:
                        tool_age_risk[tool][f"{start_age}-{start_age + bin_size - 1}"].append(risk)
                        break

        # **Compute Average Risk and Standard Deviation**
        tools = list(tool_age_risk.keys())  # ["LiFFT", "DUET", "ST"]
        age_labels = [f"{start_age}-{start_age + bin_size - 1}" for start_age in age_ranges]

        avg_risk_values = {tool: [] for tool in tools}
        std_risk_values = {tool: [] for tool in tools}

        for tool in tools:
            for age_range in age_labels:
                risks = tool_age_risk[tool].get(age_range, [])
                avg_risk_values[tool].append(np.mean(risks) if risks else 0)
                std_risk_values[tool].append(np.std(risks) if risks else 0)

        # **Set Scale Factor for Plot Size**
        scale_factor = 1.0  
        width = 0.25  # Bar width for grouped bars
        x = np.arange(len(age_labels))  # X locations for groups
    
        # **Create the Figure**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))
    
        # **Plot Bars for Each Tool with Error Bars**
        for i, tool in enumerate(tools):
            ax.bar(x + (i - 1) * width, avg_risk_values[tool], width, 
                   yerr=std_risk_values[tool], label=tool, alpha=0.75, capsize=3, color=cm.Set2(i))
    
        # **Labels & Titles (Bold Font, Adjusted Sizes)**
        ax.set_xlabel("Age Range", fontsize=8, fontweight="bold")
        ax.set_ylabel("Avg. Risk (%)", fontsize=8, fontweight="bold")
        ax.set_title("Worker Risk Distribution by Age & Tool", fontsize=7, fontweight="bold")
    
        # **X-Ticks (Age Labels)**
        ax.set_xticks(x)
        ax.set_xticklabels(age_labels, fontsize=7)

        # **Legend (Compact & Adjusted)**
        ax.legend(fontsize=7, loc="upper right", frameon=True)
    
        # **Set Y-axis limit (0-100%)**
        ax.set_ylim(0, 100)
    
        # **Ensure Layout is Optimized**
        plt.tight_layout()
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()

    
    
    
    
    def generateRiskDistributionPlot(self, workers):
        """Generates a bar chart for Risk Distribution by Station and updates self.summaryplot_canvas."""
        
        if not workers:
            print("No enabled workers found for risk distribution plot.")
            return

        # **Aggregate Data by Station**
        station_risk = {}
    
        for worker in workers:
            station = worker.get("station_id", "Unknown")
            risk = worker.get("probability_outcome", 0.0)
    
            if station in station_risk:
                station_risk[station].append(risk)
            else:
                station_risk[station] = [risk]

        # **Calculate Average Risk Per Station**
        station_labels = list(station_risk.keys())
        avg_risk_values = [sum(risks) / len(risks) for risks in station_risk.values()]

        # **Scale Factor for Plot Sizing**
        scale_factor = 1.0  # Reduce plot size to 90%
    
        # **Create the Bar Chart**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))  # Adjusted for scale
        ax.bar(station_labels, avg_risk_values, color="tomato", alpha=0.75)
    
        # **Set Labels and Title with Adjusted Font Sizes**
        ax.set_xlabel("Station", fontsize=8, fontweight="bold")  # Smaller bold label
        ax.set_ylabel("Avg. Risk (%)", fontsize=8, fontweight="bold")
        ax.set_title("Risk Distribution by Station", fontsize=10, fontweight="bold")  # Smaller title
    
        # **Adjust Tick Label Font Size**
        ax.tick_params(axis="both", labelsize=7)  # Reduce tick font size
        plt.xticks(rotation=45, ha="right", fontsize=7)  # Rotate station labels for better readability
        plt.yticks(fontsize=7)
    
        ax.set_ylim(0, 100)  # Risk is percentage-based (0-100%)
        plt.tight_layout(pad=0.5)  # Tighten layout to maximize space

        # **Store figure for expanded view**
        self.current_plot_figure = fig  # Track the last generated figure
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()



    
    def generateWorkerRiskHeatmap(self, workers):
        """Generates a heatmap for Worker Risk Levels and updates self.summaryplot_canvas."""
    
        if not workers:
            print("No enabled workers found for heatmap.")
            return
    
        # **Aggregate Data by Station and Shift**
        station_shift_risk = {}
    
        for worker in workers:
            station = worker.get("station_id", "Unknown")
            shift = worker.get("shift_id", "Unknown")
            risk = worker.get("probability_outcome", np.nan)  # Default to NaN for missing values
    
            if (station, shift) in station_shift_risk:
                station_shift_risk[(station, shift)].append(risk)
            else:
                station_shift_risk[(station, shift)] = [risk]
    
        # **Determine Unique Stations and Shifts**
        unique_stations = sorted(set(station for station, _ in station_shift_risk))
        unique_shifts = sorted(set(shift for _, shift in station_shift_risk))

        # **Initialize Risk Matrix**
        risk_matrix = np.full((len(unique_shifts), len(unique_stations)), np.nan)  # Initialize with NaN
    
        for (station, shift), risks in station_shift_risk.items():
            avg_risk = np.mean(risks)  # Compute average risk for this station-shift
            risk_matrix[unique_shifts.index(shift), unique_stations.index(station)] = avg_risk
    
        # **Scale Factor for Plot Sizing**
        scale_factor = 1.0  # Keep full size, adjust as needed
    
        # **Create Heatmap**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))  # Scale plot
        norm = Normalize(vmin=0, vmax=100)  # Normalize values between 0-100%
        heatmap = ax.imshow(risk_matrix, cmap="coolwarm", norm=norm, aspect="auto")
    
        # **Add Color Bar**
        cbar = plt.colorbar(heatmap, ax=ax)
        cbar.set_label("Risk Level (%)", fontsize=8, fontweight='bold')

        # **Set Axis Labels with Adjusted Font Sizes**
        ax.set_xticks(np.arange(len(unique_stations)))
        ax.set_xticklabels(unique_stations, rotation=45, ha="right", fontsize=7)
    
        ax.set_yticks(np.arange(len(unique_shifts)))
        ax.set_yticklabels(unique_shifts, fontsize=7)
    
        ax.set_xlabel("Station", fontsize=8, fontweight='bold')
        ax.set_ylabel("Shift", fontsize=8, fontweight='bold')
        ax.set_title("Worker Risk Levels", fontsize=10, fontweight='bold')
    
        # **Annotate Heatmap Values**
        for i in range(len(unique_shifts)):
            for j in range(len(unique_stations)):
                value = risk_matrix[i, j]
                text_color = "white" if value > 50 else "black"
                label = f"{value:.1f}" if not np.isnan(value) else "No Data"
                ax.text(j, i, label, ha="center", va="center", color=text_color, fontsize=6, fontweight='bold')
    
        plt.tight_layout(pad=0.5)  # Tighten layout to maximize space
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  # Track last generated figure
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()
    

        
    def generateRiskHeatmap(self, workers):
        """Generates a heatmap of worker risk levels across stations and updates self.summaryplot_canvas."""
    
        if not workers:
            print("No enabled workers found for risk heatmap.")
            return
    
        # **Aggregate Risk Data by Station**
        station_risk = {}
    
        for worker in workers:
            station = worker.get("station_id", "Unknown")
            risk = worker.get("probability_outcome", 0.0)  # Default to 0 if missing
    
            if station in station_risk:
                station_risk[station].append(risk)
            else:
                station_risk[station] = [risk]
    
        # **Calculate Average Risk Per Station**
        station_labels = list(station_risk.keys())
        avg_risk_values = [sum(risks) / len(risks) for risks in station_risk.values()]
    
        # **Normalize Risk Values (0-1) for Colormap**
        min_risk, max_risk = min(avg_risk_values, default=0), max(avg_risk_values, default=100)
        norm_risk_values = [(val - min_risk) / (max_risk - min_risk) if max_risk > min_risk else 0 for val in avg_risk_values]
    
        # **Grid Dimensions (Auto-arrange)**
        num_stations = len(station_labels)
        grid_size = int(np.ceil(np.sqrt(num_stations)))  # Square root rule for grid layout
    
        # **Prepare Grid Data (Fill missing spots with NaN)**
        heatmap_data = np.full((grid_size, grid_size), np.nan)  # Initialize with NaN for empty slots
        label_positions = {}  # Dictionary to track station positions

        for idx, (station, risk) in enumerate(zip(station_labels, norm_risk_values)):
            row, col = divmod(idx, grid_size)  # Compute row, col positions
            heatmap_data[row, col] = risk  # Assign normalized risk value
            label_positions[(row, col)] = station  # Store station label position
    
        # **Scale Factor for Plot Sizing**
        scale_factor = 1.0  # Keep full size, adjust as needed
    
        # **Plot the Heatmap**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))  # Scaled plot size
        cmap = plt.cm.RdYlGn_r  # Red-Yellow-Green (reversed)
        norm = Normalize(vmin=0, vmax=1)  # Normalize to 0-1 range
    
        # **Generate Heatmap**
        heatmap = ax.imshow(heatmap_data, cmap=cmap, norm=norm, aspect='auto')
    
        # **Overlay Station Labels**
        for (row, col), station in label_positions.items():
            ax.text(col, row, station, ha="center", va="center", fontsize=6, fontweight="bold", color="black")
    
        # **Colorbar (Legend)**
        cbar = plt.colorbar(ScalarMappable(norm=norm, cmap=cmap), ax=ax, shrink=0.8)
        cbar.set_label("Risk Level (%)", fontsize=8, fontweight="bold")
    
        # **Remove Grid Ticks**
        ax.set_xticks([])
        ax.set_yticks([])
        ax.set_title("Worker Risk Heatmap by Station", fontsize=8, fontweight="bold")
    
        plt.tight_layout()
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  # Store last generated figure
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()


    def generateWorkerDistributionPlot(self, workers):
        """Generates a grouped bar chart for Worker Distribution by Gender & Tool and updates self.summaryplot_canvas."""
        
        if not workers:
            print("No enabled workers found for worker distribution plot.")
            return
    
        # **Initialize Counters for Each Tool & Gender**
        gender_tool_counts = {
            "LiFFT": {"male": 0, "female": 0},
            "DUET": {"male": 0, "female": 0},
            "ST": {"male": 0, "female": 0}
        }
    
        # **Aggregate Data by Tool & Gender**
        for worker in workers:
            tool = worker.get("tool_id", "").strip()
            gender = worker.get("gender", "").strip().lower()

            if tool in gender_tool_counts:
                if gender == "male":
                    gender_tool_counts[tool]["male"] += 1
                elif gender == "female":
                    gender_tool_counts[tool]["female"] += 1
    
        # **Extract Data for Plotting**
        tools = list(gender_tool_counts.keys())  # ["LiFFT", "DUET", "ST"]
        male_counts = [gender_tool_counts[tool]["male"] for tool in tools]
        female_counts = [gender_tool_counts[tool]["female"] for tool in tools]
    
        # **Set Scale Factor for Plot Size**
        scale_factor = 1.0  
    
        # **Set Bar Width & Positions**
        x = np.arange(len(tools))  # X locations for groups
        width = 0.3  # Bar width (adjusted for spacing)
    
        # **Create the Figure**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))
    
        # **Plot Bars for Males & Females**
        bars1 = ax.bar(x - width/2, male_counts, width, label="Male", color="royalblue", alpha=0.75)
        bars2 = ax.bar(x + width/2, female_counts, width, label="Female", color="lightcoral", alpha=0.75)
    
        # **Labels & Titles (Bold Font, Adjusted Sizes)**
        ax.set_xlabel("Tool Type", fontsize=8, fontweight="bold")
        ax.set_ylabel("Number of Workers", fontsize=8, fontweight="bold")
        ax.set_title("Worker Distribution by Gender & Tool", fontsize=9, fontweight="bold")
    
        # **X-Ticks (Tool Labels)**
        ax.set_xticks(x)
        ax.set_xticklabels(tools, fontsize=7)
    
        # **Legend (Compact & Adjusted)**
        ax.legend(fontsize=7, loc="upper right", frameon=True)
    
        # **Ensure Layout is Optimized**
        plt.tight_layout()
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()


        
    def generateRiskVsAgePlot(self, workers):
        """Generates a scatter plot of Risk vs. Age of Workers and updates self.summaryplot_canvas."""
        
        if not workers:
            print("No enabled workers found for Risk vs. Age scatter plot.")
            return
    
        # **Filter Only Enabled Workers**
        enabled_workers = [worker for worker in workers if worker.get("enable", 0) == 1]
    
        # **Extract Data: Age & Risk Levels**
        ages = []
        risks = []
        
        for worker in enabled_workers:
            if worker.get("year_of_birth"):
                age = QDate.currentDate().year() - worker["year_of_birth"]  # Calculate Age
                risk = worker.get("probability_outcome", 0.0)  # Get Risk Percentage
                
                ages.append(age)
                risks.append(risk)
    
        if not ages or not risks:
            print("Warning: No valid age-risk data for scatter plot.")
            return
    
        # **Set Scale Factor for Plot Size**
        scale_factor = 1.0  
    
        # **Create the Scatter Plot**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))
    
        # **Color Mapping: Red for High Risk, Green for Low Risk**
        colors = cm.RdYlGn_r(np.array(risks) / 100)  # Normalize risk values for colormap
        
        scatter = ax.scatter(
            ages, risks, c=colors, cmap="RdYlGn_r", edgecolors="black", s=20, alpha=0.75
        )
    
        # **Labels & Titles (Bold Font, Adjusted Sizes)**
        ax.set_xlabel("Worker Age", fontsize=8, fontweight="bold")
        ax.set_ylabel("Risk Level (%)", fontsize=8, fontweight="bold")
        ax.set_title("Risk vs. Age of Workers", fontsize=9, fontweight="bold")
    
        # **Grid & Limits**
        ax.set_ylim(0, 100)  # Risk is a percentage (0-100%)
        ax.set_xlim(min(ages) - 2, max(ages) + 2)  # Add slight padding to age range
        ax.grid(True, linestyle="--", alpha=0.5)
    
        # **Color Bar (Legend for Risk Levels)**
        cbar = fig.colorbar(scatter, ax=ax)
        cbar.set_label("Risk Level (%)", fontsize=7, fontweight="bold")

        # **Ensure Layout is Optimized**
        plt.tight_layout()
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()

    
    
    
    def generateCumulativeRiskOverTimePlot(self, workers):
        """Generates a line chart for Cumulative Risk Over Time and updates self.summaryplot_canvas."""
        
        if not workers:
            print("No enabled workers found for cumulative risk over time plot.")
            return
    
        # **Filter Only Enabled Workers**
        enabled_workers = [worker for worker in workers if worker.get("enable", 0) == 1]
    
        # **Extract Data: Time (Years of Experience) & Cumulative Risk**
        experience_years = []
        cumulative_risks = []
    
        for worker in enabled_workers:
            if worker.get("year_of_hiring") and worker.get("probability_outcome") is not None:
                experience = QDate.currentDate().year() - worker["year_of_hiring"]  # Years of Experience
                risk = worker["probability_outcome"]
    
                experience_years.append(experience)
                cumulative_risks.append(risk)
    
        if not experience_years or not cumulative_risks:
            print("Warning: No valid experience-risk data for line chart.")
            return
    
        # **Sort Data by Experience Years**
        sorted_indices = np.argsort(experience_years)
        experience_years = np.array(experience_years)[sorted_indices]
        cumulative_risks = np.array(cumulative_risks)[sorted_indices]

        # **Compute Cumulative Risk**
        cumulative_risks = np.cumsum(cumulative_risks) / np.arange(1, len(cumulative_risks) + 1)
    
        # **Set Scale Factor for Plot Size**
        scale_factor = 1.0  
    
        # **Create the Line Chart**
        fig, ax = plt.subplots(figsize=(3.1 * scale_factor, 2.3 * scale_factor))
    
        ax.plot(
            experience_years, cumulative_risks, 
            marker="o", linestyle="-", color="blue", alpha=0.75, linewidth=2, markersize=4
        )
    
        # **Labels & Titles (Bold Font, Adjusted Sizes)**
        ax.set_xlabel("Years of Experience", fontsize=8, fontweight="bold")
        ax.set_ylabel("Cumulative Risk (%)", fontsize=8, fontweight="bold")
        ax.set_title("Cumulative Risk Over Time", fontsize=9, fontweight="bold")
    
        # **Grid & Limits**
        ax.set_ylim(0, 100)  # Risk is percentage-based (0-100%)
        ax.set_xlim(min(experience_years) - 1, max(experience_years) + 1)  # Add slight padding
        ax.grid(True, linestyle="--", alpha=0.5)
    
        # **Ensure Layout is Optimized**
        plt.tight_layout()
    
        # **Store figure for expanded view**
        self.current_plot_figure = fig  
    
        # **Clear Canvas and Render New Plot**
        self.summaryplot_canvas.figure = fig
        self.summaryplot_canvas.draw()


    
    
    
    def loadOutcome(self):
        """Calculates the average color from the dataset and applies it to self.outcome_image."""
    
        if not hasattr(self, "workerstationshifttool_dataset") or not self.workerstationshifttool_dataset:
            print("Error: workerstationshifttool_dataset is empty or not available.")
            return
    
        # **Filter dataset to only include enabled workers**
        enabled_workers = [worker for worker in self.workerstationshifttool_dataset if worker.get("enable", 0) == 1]
        
        
        # ** Initialize Color Accumulators**
        total_r, total_g, total_b = 0, 0, 0
        count = 0
    
        # **Loop Through Dataset to Sum Colors**
        #for worker in self.workerstationshifttool_dataset:
        for worker in enabled_workers:
            hex_color = worker.get("color", "#72ff00")  # Default to black
            color = QColor(hex_color)  # Convert hex to QColor
    
            if color.isValid():
                total_r += color.red()
                total_g += color.green()
                total_b += color.blue()
                count += 1
    
        # **Calculate Average Color**
        if count > 0:
            avg_r = total_r // count
            avg_g = total_g // count
            avg_b = total_b // count
        else:
            avg_r, avg_g, avg_b = 0, 0, 0  # Default to black if no valid colors
    
        avg_color = QColor(avg_r, avg_g, avg_b)
    
        # Disable scrollbars to prevent them from appearing
        self.outcome_image.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.outcome_image.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        
        # **Apply Color to GraphicsView**
        scene = QGraphicsScene(self)
        rect_item = QGraphicsRectItem(0, 0, self.outcome_image.width(), self.outcome_image.height())
        rect_item.setBrush(QBrush(avg_color, Qt.SolidPattern))
        scene.addItem(rect_item)
    
        self.outcome_image.setScene(scene)
        
        
        
        # **Check for High-Risk Stations**
        high_risk_threshold = 50  # TODO: set in another way...
        station_risk_count = {}

        for worker in enabled_workers:  # Use only enabled workers
            station_id = worker.get("station_id", "")
            probability_outcome = worker.get("probability_outcome", 0.0)  # Ensure it's a float

            if probability_outcome >= high_risk_threshold:
                if station_id in station_risk_count:
                    station_risk_count[station_id] += 1
                else:
                    station_risk_count[station_id] = 1

        # **Identify Stations with 2+ High-Risk Workers**
        high_risk_stations = [station for station, count in station_risk_count.items() if count >= 2]

        # **Update the Outcome Label Based on Results**
        if high_risk_stations:
            station_list_str = ", ".join(high_risk_stations)
            warning_message = f"Warning: Stations with multiple high-risk workers (>{high_risk_threshold}%): {station_list_str}"

            self.outcomeresult1_label.setText(warning_message)
            self.outcomeresult1_label.setStyleSheet("color: red; font-weight: bold;")  # Highlight warning
            self.outcomeresult1_label.setToolTip(warning_message)
            
        else:
            self.outcomeresult1_label.setText("")  # Clear message if no issues found
            self.outcomeresult1_label.setToolTip("")


    
    
    
    
    
        
    # save the loaded image into the db        
    def savePlantImage(self):
        """
        Saves the currently loaded image to the project folder, renames it based on the plant name,
        and updates the database with the new image path.
        """
        # Ensure an image has been selected and loaded
        if not hasattr(self, 'temp_plant_image_path') or not self.temp_plant_image_path:
            QMessageBox.warning(self, "Error", "No image has been loaded. Please load an image first.")
            return
    
        # Ensure a project file is created
        if not self.parent().projectFileCreated:
            QMessageBox.warning(self, "Error", "No project file loaded. Please create or load a project first.")
            return
    
        # Get the current plant name from the combo box
        plant_name = self.plant_combo.currentText().strip()
        
        if not plant_name or plant_name == "All":
            QMessageBox.warning(self, "Error", "Please select a valid plant before saving an image.")
            return
        
        # Get project paths from parent
        project_folder = self.parent().projectFolderPath
        image_folder = self.parent().imagesFolder
    
        if not project_folder or not image_folder:
            QMessageBox.critical(self, "Error", "Project folder paths are not set. Cannot save image.")
            return
    
        # Ensure the image folder exists
        save_folder = os.path.join(project_folder, image_folder)
        os.makedirs(save_folder, exist_ok=True)
    
        # Get the image extension
        file_extension = os.path.splitext(self.temp_plant_image_path)[1].lower()
        if file_extension not in [".png", ".jpg"]:
            QMessageBox.warning(self, "Error", "Invalid image format. Please select a PNG or JPG file.")
            return
    
        # Create the new file name
        new_image_name = f"{plant_name}_layout{file_extension}"
        new_image_path = os.path.join(save_folder, new_image_name)
        
        new_image_relpath = os.path.join(image_folder, new_image_name)
    
        try:
            # Copy the selected image to the project image folder
            shutil.copy(self.temp_plant_image_path, new_image_path)
    
            # Update the Plant table in the database
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            cursor = conn.cursor()
            cursor.execute(
                "UPDATE Plant SET image_name = ?, image_path = ? WHERE name = ?",
                (new_image_name, new_image_relpath, plant_name)
            )
            conn.commit()
            conn.close()
    
            QMessageBox.information(self, "Success", "Plant image has been saved successfully.")
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to save plant image:\n{str(e)}")

    
    def loadPlantImage(self):
        """
        Loads the plant image from the database using the plant name in the combo box.
        If no image is found, it clears the image display.
        """
        # Ensure a project file is created
        if not self.parent().projectFileCreated:
            QMessageBox.warning(self, "Error", "No project file loaded. Please create or load a project first.")
            return
    
        # Get the current plant name from the combo box
        plant_name = self.plant_combo.currentText().strip()
        
        if not plant_name or plant_name == "All":
            QMessageBox.warning(self, "Error", "Please select a valid plant before loading an image.")
            return
    
        # Get project paths from parent
        project_folder = self.parent().projectFolderPath
        image_folder = self.parent().imagesFolder
    
        if not project_folder or not image_folder:
            QMessageBox.critical(self, "Error", "Project folder paths are not set. Cannot load image.")
            return
        try:
            # Connect to database and fetch image info
            conn = sqlite3.connect(self.parent().projectdatabasePath)
            cursor = conn.cursor()
            cursor.execute("SELECT image_name, image_path FROM Plant WHERE name = ?", (plant_name,))
            result = cursor.fetchone()
            conn.close()
            
            if result:
                image_name, image_path = result
    
    
                image_fullpathname = "" #os.path.normpath(os.path.join(project_folder, image_folder, image_name))
                #print("image_fullpathname:", image_pathname) 
                if all(isinstance(param, str) and param for param in [project_folder, image_folder, image_name]):
                    image_fullpathname = os.path.normpath(os.path.join(project_folder, image_folder, image_name))
                 #   print(f"Image Full Path: {image_fullpathname}")
                #else:
                 #   print("Error: One or more path components are invalid or empty.")
    
                # If image_name or image_path is None/empty, clear the image display
                #if not image_name or not image_path or not os.path.exists(image_path):
                if not image_name or not image_fullpathname or not os.path.exists(image_fullpathname):
                    #print(f"No valid image found for {plant_name}. Clearing image display.")
                    self.plantlayout_scene.clear()
                    #return
                else:
                    # Load the image into the UI
                    #self.loadImage(image_path, self.plantlayout_scene, self.plantlayout_image, 0.9, 0.9)
                    #self.loadImageNew(image_path, self.plantlayout_scene, self.plantlayout_image)
                    self.loadImageNew(image_fullpathname, self.plantlayout_scene, self.plantlayout_image)
                    
                    
                    
    
            else:
                print(f"No image record found for {plant_name}. Clearing image display.")
                self.plantlayout_scene.clear()
    
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load plant image:\n{str(e)}")

    
    
    
    
    
        
    def addOperator(self):
        #self.operator_count += 1
        #name = f"Operator {self.operator_count}"
        #age = random.randint(20, 60)
        #damage = random.randint(0, 100)
        #risk = f"{random.randint(0, 100)}%"
        #pixmap_path = random.choice(["../images/operator_icon02.png", "../images/operator_icon03.png"])
        #pixmap = QPixmap(pixmap_path).scaled(40, 40, Qt.KeepAspectRatio)

        #item = DraggablePixmapItem(pixmap, name, age, damage, risk)
        #self.plantlayout_scene.addItem(item)

        # Random offset for positioning
        #offset_x = random.randint(5, 15)
        #offset_y = random.randint(5, 15)
        #item.setPos(0 + offset_x * self.operator_count, 0 + offset_y * self.operator_count)

        self.operator_count += 1

        # Randomly select shape type (square or circle)
        shape_type = random.choice(["triangle", "circle"])

        # Generate random color in red, green, or yellow tones
        color_choices = [
            (random.randint(150, 255), random.randint(0, 100), random.randint(0, 100)),  # Red-ish
            (random.randint(0, 100), random.randint(150, 255), random.randint(0, 100)),  # Green-ish
            (random.randint(150, 255), random.randint(150, 255), random.randint(0, 100))  # Yellow-ish
        ]
        color = QColor(*random.choice(color_choices))

        # Randomly select a letter (L, D, or S)
        letter = random.choice(["L", "D", "S"])

        # Generate random data for tooltip
        name = f"Operator {self.operator_count}"
        age = random.randint(20, 60)
        damage = random.randint(0, 100)
        risk = f"{random.randint(0, 100)}%"

        # Create and add item
        #item = DraggableShapeItem(shape_type, color, letter, name, age, damage, risk)
        #item = DraggableShapeItem(self.plantlayout_scene, shape_type, color, letter, name, age, damage, risk)
        
        #item = VisualWorkerTool(self.plantlayout_scene, shape_type, color, letter, name, age, damage, risk)
        
        
        # Create a fake data row with all necessary fields
        fake_datarow = {
            "worker_id": "SSN001",
            "plant_name": "Default",
            "section_name": "Default",
            "line_name": "Default",
            "station_id": "Default",
            "shift_id": "1",
            "tool_id": "LiFFT",
            "total_cumulative_damage": 0.0001,
            "probability_outcome": 8.5,
        
            # **Visual Properties**
            "x": 100, "y": 200, "width": 50, "ws_height": 50,
            "scale_x": 1.0, "scale_y": 1.0, "rotation": 0.0, "transparency": 0.0,
            "enable": 1, "visible": 1,
            
            # **Color & Shape Properties**
            "color": "#ff2e00",  # Red color
            "r": 255, "g": 46, "b": 0,  # RGB values (not used in this test)
        
            # **Worker Details**
            "first_name": "Mauricio",
            "last_name": "Henriquez",
            "year_of_birth": 1985,
            "month_of_birth": 7,
            "day_of_birth": 15,
            "gender": "Male",  # This should make it a "triangle"
            "worker_height": 180.0,
            "worker_weight": 75.0
        }

        # **Pass fake datarow to the constructor**
        self.worker = VisualWorkerTool(self.plantlayout_scene, fake_datarow)
        #self.worker.setX(100)
        
        
        #self.plantlayout_scene.addItem(worker)

        # Random offset for positioning in the top right corner
        offset_x = random.randint(5, 15)
        offset_y = random.randint(5, 15)
        #item.setPos(0 + offset_x * self.operator_count, 0 + offset_y * self.operator_count)
         






if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = PlantLayoutWindow()
    window.show()
    sys.exit(app.exec_())

 


