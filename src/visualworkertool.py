# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled02.ui'
#
# Created by: PyQt5 UI code generator 5.15.10
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import sys
import os
import shutil
import math

from PyQt5.QtWidgets import (QApplication, QDialog, QVBoxLayout, QHBoxLayout, QLabel, QComboBox, QDateEdit,
                             QPushButton, QFrame, QGraphicsView, QGraphicsScene, QToolButton, QCheckBox, QGroupBox, QGridLayout, QStatusBar, QGraphicsPixmapItem, QMenu, QAction, QSpinBox, QGraphicsRectItem)
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QPixmap, QCursor, QPen, QIcon, QBrush, QColor, QPolygonF, QFont, QPainter, QFontMetrics
from PyQt5.QtCore import Qt, QDate, QSize, QPointF, QRectF
from PyQt5.QtWidgets import QWidget, QGraphicsItem, QGraphicsEllipseItem, QGraphicsRectItem, QFileDialog, QGraphicsItem, QGraphicsPolygonItem
from PyQt5 import QtWidgets, QtCore 

import random
import sqlite3

#from PyQt5.QtGui import QIcon, QPixmap, QFont


import sys
from PyQt5.QtWidgets import (
    QApplication, QDialog, QVBoxLayout, QHBoxLayout, QGroupBox,
    QLabel, QComboBox, QPushButton, QGraphicsView, QGraphicsScene, QMessageBox, QLineEdit
)
from PyQt5.QtGui import QPixmap, QIcon, QFont
from PyQt5.QtCore import Qt




class VisualWorkerTool(QGraphicsItem):
    def __init__(self, scene, datarow, scale):
        """
        Initializes a graphical representation of a worker tool using data from a row dictionary.

        Args:
            scene (QGraphicsScene): The scene where the item will be displayed.
            row (dict): A dictionary containing all the fields from WorkerStationShiftErgoTool.
        """
        super().__init__()
        self.setFlag(QGraphicsItem.ItemIsMovable)
        self.setFlag(QGraphicsItem.ItemIsSelectable)
        self.parentScene = scene
        self.border = False
        self.loadIntoTool = False
        
        self.datarow = datarow
        
        self.loadscale = scale
        #self.sfi = round(2 - self.scale, 2)
        self.sfi = round(1/self.loadscale, 2)  # self.sfi = Scale Factor Internal
        
        self.scale = 1.0
        #print("DataRow:", datarow)
        
        # **Map values from the dataset row**
        self.worker_id = datarow.get("worker_id", "Unknown")
        self.plant_name = datarow.get("plant_name", "")
        self.section_name = datarow.get("section_name", "")
        self.line_name = datarow.get("line_name", "")
        self.station_id = datarow.get("station_id", "")
        self.shift_id = datarow.get("shift_id", "")
        self.tool_id = datarow.get("tool_id", "")
    
        self.total_cumulative_damage = datarow.get("total_cumulative_damage", 0.0)
        self.probability_outcome = datarow.get("probability_outcome", 0.0)
        
        # **Additional results**
        self.result_3 = datarow.get("result_3", 0.0)
        self.result_4 = datarow.get("result_4", 0.0)
        self.result_5 = datarow.get("result_5", 0.0)
        self.result_6 = datarow.get("result_6", 0.0)
        self.result_7 = datarow.get("result_7", 0.0)
        self.result_8 = datarow.get("result_8", 0.0)
        self.result_9 = datarow.get("result_9", 0.0)
        
        # **Unit**
        self.unit = datarow.get("unit", "")
        
        # **Worker Details**
        self.first_name = datarow.get("first_name", "")
        self.last_name = datarow.get("last_name", "")
        self.year_of_birth = datarow.get("year_of_birth", 0)
        self.month_of_birth = datarow.get("month_of_birth", 0)
        self.day_of_birth = datarow.get("day_of_birth", 0)
        self.gender = datarow.get("gender", "N/A")
        self.worker_height = datarow.get("worker_height", 0.0)
        self.worker_weight = datarow.get("worker_weight", 0.0)
    
        # **Visual Elements (Mapping Directly)**
        self.x = datarow.get("x", 0.0)
        self.y = datarow.get("y", 0.0)
        
        self.xi = datarow.get("x", 0.0)  # Use it to store internal values for x
        self.yi = datarow.get("y", 0.0)  # Use it to store internal values for x
        
        
        self.width = datarow.get("width", 50.0)
        self.height = datarow.get("ws_height", 50.0)
        self.line_thickness = datarow.get("line_thickness", 1.0)
        self.scale_x = datarow.get("scale_x", 1.0)
        self.scale_y = datarow.get("scale_y", 1.0)
        
        self.scale = self.scale_x # Same scale for both x, y
        
        self.crop_x = datarow.get("crop_x", 0.0)
        self.crop_y = datarow.get("crop_y", 0.0)
        self.crop_width = datarow.get("crop_width", self.width)
        self.crop_height = datarow.get("crop_height", self.height)
        self.zoom = datarow.get("zoom", 1.0)
        self.rotation = datarow.get("rotation", 0.0)
        self.mirror_h = datarow.get("mirror_h", 0)
        self.mirror_v = datarow.get("mirror_v", 0)
        self.orientation = datarow.get("orientation", "Horizontal")
        self.brightness = datarow.get("brightness", 1.0)
        self.contrast = datarow.get("contrast", 1.0)
        self.saturation = datarow.get("saturation", 1.0)
        self.lock = datarow.get("lock", 0)
        self.visible = datarow.get("visible", 1)
        self.transparency = datarow.get("transparency", 0.0)
        self.enable = datarow.get("enable", 1)

        # **Convert hex color to QColor**
        hex_color = datarow.get("color", "#72ff00")  # Default to green if missing
        self.color = QColor(hex_color)
        
        
        #print(datarow.get("gender", ""))
        # Assign shape based on gender
        # Validate gender field before processing
        gender = datarow.get("gender", "").strip().lower() if datarow.get("gender") else "other"

        if gender == "female":
            self.shape = "circle"
        elif gender == "male":
            self.shape = "triangle"
        else:
            self.shape = "square"  # Default for unspecified or other genders

        
     
        # **Tooltip for Worker Details**
        self.setCustomToolTip()

        self.initShape()
        
        
        # NEW: Attributes for zooming
        self._zooming = False
        self._zoomStartPos = None
        self._initialScale = None
        
        
        self.isSaveAt = False # TODO: remove it, it should not be needed

        # **Add to Scene only if visible**
        if self.visible:
            self.parentScene.addItem(self)
        

    def setCustomToolTip(self):
       """Sets a tooltip displaying worker details including ID, name, age, location details (Section, Line, Station, Shift),
       cumulative damage, and risk probability."""
       self.setToolTip(
            f"ID: {self.worker_id}\n"
            f"Name: {self.first_name} {self.last_name}\n"
            f"Age: {self.getAge()}\n"
            f"Section: {self.section_name}\n"
            f"Line: {self.line_name}\n"
            f"Station: {self.station_id}\n"
            f"Shift: {self.shift_id}\n"
            f"Cumulative Damage: {self.total_cumulative_damage}\n"
            f"Risk Probability: {self.probability_outcome}%"
        )

    
    

    def initShapeN(self):
        """Creates and assigns the graphical shape (circle, triangle, or square) to the worker item."""

        if hasattr(self, 'item') and self.item:  
            self.scene().removeItem(self.item)  # Remove existing shape if any
    
        # self.sfi = Scale Factor Internal
        #self.sfi = round(2 - self.scale, 2)
        #print("sf:", self.sfi)
        if self.shape == 'circle':
            self.item = QGraphicsEllipseItem(self.xi, self.yi, self.width * self.sfi * float(self.scale), self.height * self.sfi * float(self.scale), self)
    
        elif self.shape == 'triangle': # Pointing upward
            triangle = QPolygonF([
                QPointF(self.xi + (self.width * self.sfi * float(self.scale)) / 2, self.yi),  # Top point
                QPointF(self.xi + (self.width * self.sfi* float(self.scale)), self.yi + (self.height * self.sfi * float(self.scale))),  # Bottom right
                QPointF(self.xi, self.yi + (self.height * self.sfi * float(self.scale)))  # Bottom left
            ])
            self.item = QGraphicsPolygonItem(triangle, self)
    
        #elif self.shape == 'triangle': # Pointing downward
        #    triangle = QPolygonF([
        #    QPointF(self.x, self.y),  # Top left (was bottom left)
        #    QPointF(self.x + (self.width * self.sfi * scale), self.y),  # Top right (was bottom right)
        #    QPointF(self.x + (self.width * self.sfi * scale) / 2, self.y + (self.height * self.sfi * scale))  # Bottom center (was top point)
        #    ])
        #    self.item = QGraphicsPolygonItem(triangle, self)

        elif self.shape == 'square':  
            self.item = QGraphicsRectItem(self.xi, self.yi, self.width * self.sfi * float(self.scale), self.height * self.sfi * float(self.scale), self)
    
        # Apply color and remove outline
        self.item.setBrush(QBrush(self.color, Qt.SolidPattern))
        self.item.setPen(QPen(Qt.NoPen))

    def initShape(self):
        """Creates and assigns the graphical shape (circle, triangle, or square) to the worker item."""

        if hasattr(self, 'item') and self.item:  
            self.scene().removeItem(self.item)  # Remove existing shape if any
    
        # self.sfi = Scale Factor Internal
        #self.sfi = round(2 - self.scale, 2)
        #print("sf:", self.sfi)
        if self.shape == 'circle':
            self.item = QGraphicsEllipseItem(self.x, self.y, self.width * self.sfi * float(self.scale), self.height * self.sfi * float(self.scale), self)
    
        elif self.shape == 'triangle': # Pointing upward
            triangle = QPolygonF([
                QPointF(self.x + (self.width * self.sfi * float(self.scale)) / 2, self.y),  # Top point
                QPointF(self.x + (self.width * self.sfi* float(self.scale)), self.y + (self.height * self.sfi * float(self.scale))),  # Bottom right
                QPointF(self.x, self.y + (self.height * self.sfi * float(self.scale)))  # Bottom left
            ])
            self.item = QGraphicsPolygonItem(triangle, self)
    
        #elif self.shape == 'triangle': # Pointing downward
        #    triangle = QPolygonF([
        #    QPointF(self.x, self.y),  # Top left (was bottom left)
        #    QPointF(self.x + (self.width * self.sfi * scale), self.y),  # Top right (was bottom right)
        #    QPointF(self.x + (self.width * self.sfi * scale) / 2, self.y + (self.height * self.sfi * scale))  # Bottom center (was top point)
        #    ])
        #    self.item = QGraphicsPolygonItem(triangle, self)

        elif self.shape == 'square':  
            self.item = QGraphicsRectItem(self.x, self.y, self.width * self.sfi * float(self.scale), self.height * self.sfi * float(self.scale), self)
    
        # Apply color and remove outline
        self.item.setBrush(QBrush(self.color, Qt.SolidPattern))
        self.item.setPen(QPen(Qt.NoPen))

    def initShapeAt(self): # TODO: remove it, it should not be needed
        """Creates and assigns the graphical shape (circle, triangle, or square) to the worker item."""

        if hasattr(self, 'item') and self.item:  
            self.scene().removeItem(self.item)  # Remove existing shape if any
    
        # self.sfi = Scale Factor Internal
        #self.sfi = round(2 - self.scale, 2)
        #print("sf:", self.sfi)
        if self.shape == 'circle':
            self.item = QGraphicsEllipseItem(self.xi, self.yi, self.width * self.sfi * float(self.scale), self.height * self.sfi * float(self.scale), self)
    
        elif self.shape == 'triangle': # Pointing upward
            triangle = QPolygonF([
                QPointF(self.xi + (self.width * self.sfi * float(self.scale)) / 2, self.yi),  # Top point
                QPointF(self.xi + (self.width * self.sfi* float(self.scale)), self.yi + (self.height * self.sfi * float(self.scale))),  # Bottom right
                QPointF(self.xi, self.yi + (self.height * self.sfi * float(self.scale)))  # Bottom left
            ])
            self.item = QGraphicsPolygonItem(triangle, self)
    
        #elif self.shape == 'triangle': # Pointing downward
        #    triangle = QPolygonF([
        #    QPointF(self.x, self.y),  # Top left (was bottom left)
        #    QPointF(self.x + (self.width * self.sfi * scale), self.y),  # Top right (was bottom right)
        #    QPointF(self.x + (self.width * self.sfi * scale) / 2, self.y + (self.height * self.sfi * scale))  # Bottom center (was top point)
        #    ])
        #    self.item = QGraphicsPolygonItem(triangle, self)

        elif self.shape == 'square':  
            self.item = QGraphicsRectItem(self.xi, self.yi, self.width * self.sfi * float(self.scale), self.height * self.sfi * float(self.scale), self)
    
        # Apply color and remove outline
        self.item.setBrush(QBrush(self.color, Qt.SolidPattern))
        self.item.setPen(QPen(Qt.NoPen))



    def boundingRectAt(self): # TODO: remove it, it should not be needed
        x_value = self.xi
        #x_value = round(float(x_value) - ((float(self.width) * float(self.sfi) * float(self.scale)) / 2)) 
        y_value = self.yi
        #y_value = round(float(y_value) - ((float(self.height) * float(self.sfi) * float(self.scale)) / 2)) 
        
        return QRectF(float(x_value), float(y_value), float(self.width) * float(self.sfi) * float(self.scale), float(self.height) * float(self.sfi) * float(self.scale))
        
    def boundingRect(self):
        return QRectF(float(self.x), float(self.y), float(self.width) * float(self.sfi) * float(self.scale), float(self.height) * float(self.sfi) * float(self.scale))



    def mouseMoveEvent(self, event):
        # If we are zooming, update the scale factor based on the vertical mouse movement.
        if self._zooming:
            # Compute how far the mouse has moved vertically from the initial press point.
            delta = event.scenePos().y() - self._zoomStartPos.y()
            # A simple formula: drag up (delta negative) zooms in, drag down zooms out.
            factor = 1 - (delta / 100.0)
            new_scale = self._initialScale * factor
            # Clamp the scale factor to avoid it becoming too small or too large.
            new_scale = max(0.1, min(new_scale, 10))
            #self.scale = new_scale
            self.scale = round(1 / new_scale, 2)
           
             
            if hasattr(self.parentScene.parent(), 'scaleinfo_input'):
                self.parentScene.parent().scaleinfo_input.setText(str(self.scale)) 
            
            
            # IMPORTANT: call prepareGeometryChange() before changing the boundingRect.
            self.prepareGeometryChange()
            self.initShape()
            self.update()
            # When zooming, do not update the position.
            return
        #if self._zooming:
        #    current_pos = event.scenePos()
        #    dy = current_pos.y() - self._zoomStartPos.y()
        #    # Adjust sensitivity: here, each pixel vertically adjusts scale by 1%.
        #    factor = 1 + (dy * 0.01)
        #    new_scale = self._initialScale * factor
        #    
        #    # Clamp the scale to a reasonable range.
        #    new_scale = max(0.1, min(new_scale, 10))
        #    
        #    # Update the transformation scale.
        #    self.setScale(new_scale)
        #    event.accept()
        #    return
  
  
        new_position = event.scenePos()
        
        # To avoid borders....
        # Get fixed dimensions of the QGraphicsView (image control)
        #view = self.parentScene.views()[0]  # The first view displaying the scene, this is the graphic object, allways return 970x580
        #view_width = view.width()
        #view_height = view.height()
        #print("View Width:", view_width)
        #print("View Height:", view_height)
        
        # Retrieve Scene Dimensions
        scene_rect = self.parentScene.sceneRect()
        scene_width = scene_rect.width()   # Scene width
        scene_height = scene_rect.height() # Scene height
        #print("Scene Width:", scene_width)
        #print("Scene Height:", scene_height)

        #if ((int(new_position.x()) < 15) or ( (int(new_position.x() * self.sfi) + self.width ) > scene_width)):
        #if (int(new_position.x()) < 15):
        #    event.ignore()  # Reject the event
        #    return
       
        # ............
        
        
        
        # Otherwise, normal move behavior.
        #new_position = event.scenePos()
        self.xi = int(new_position.x())
        self.datarow["x"] = self.xi
        self.yi = int(new_position.y())
        self.datarow["y"] = self.yi
        
        if hasattr(self.parentScene.parent(), 'xinfo_input') and hasattr(self.parentScene.parent(), 'yinfo_input'):
            x_value = self.xi
            x_value = round(float(x_value) - ((float(self.width) * float(self.sfi) * float(self.scale)) / 2)) 
        
            #self.parentScene.parent().xinfo_input.setText(str(self.xi))
            self.parentScene.parent().xinfo_input.setText(str(x_value))
            
            
            y_value = self.yi
            y_value = round(float(y_value) - ((float(self.height) * float(self.sfi) * float(self.scale)) / 2))
            #self.parentScene.parent().yinfo_input.setText(str(self.yi))
            self.parentScene.parent().yinfo_input.setText(str(y_value))
            
        super().mouseMoveEvent(event)

    
        
        
    

    def paint(self, painter, option, widget=None):
        if self.border:
            if  (self.isSaveAt == False):
                rect = self.boundingRect()
            else:
                rect = self.boundingRectAt()
                self.isSaveAt = False
                
            bw = math.ceil(1 * self.sfi) + 2 # TODO: more tests!!!
            if bw >= 5:
                bw = 4
            #print("border width:", bw)
            pen = QPen(Qt.blue, bw, Qt.SolidLine)
            painter.setPen(pen)
            painter.drawRect(rect)
        
        
        # TODO: check why it dosn't work!!!, it seems is allways draw under the color..
        ## Draw the letter
        #painter.setPen(Qt.black)
        #painter.setFont(QFont("Arial", 20, QFont.Bold))
        #painter.drawText(self.boundingRect(), Qt.AlignCenter, self.letter)


    def paintAt(self, painter):
        if self.border:
            rect = self.boundingRectAt()
            bw = math.ceil(1 * self.sfi) + 2 # TODO: more tests!!!
            if bw >= 5:
                bw = 4
            #print("border width:", bw)
            pen = QPen(Qt.blue, bw, Qt.SolidLine)
            painter.setPen(pen)
            painter.drawRect(rect)
    
    
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            # If Control is held down, we start zooming instead of moving.
            if event.modifiers() & Qt.ControlModifier:
                self._zooming = True
                self._zoomStartPos = event.scenePos()
                self._initialScale = self.scale
                self.setCursor(Qt.SizeVerCursor)  # Indicate zooming with a vertical resize cursor
                # Do not call super() here so that we don't trigger the normal move behavior.
           
                return
            else:
                # Normal left-click behavior: show a border, select the item, etc.
                self.border = True
                self.update()
                
                parent = self.parentScene.parent()
                if hasattr(parent, 'selectWorkerInComboBox'):
                    parent.selectWorkerInComboBox(self)
        elif event.button() == Qt.RightButton:
            self.showContextMenu(event)
                    
        super().mousePressEvent(event)
    
    
    def mousePressEventW(self, event):
        if event.button() == Qt.LeftButton:
            self.border = True
            self.update()
            
            parent = self.parentScene.parent()
            if hasattr(parent, 'selectWorkerInComboBox'):
                parent.selectWorkerInComboBox(self)  # Send self (this object) as parameter
        
                    
        elif event.button() == Qt.RightButton:
            self.showContextMenu(event)
            
        super().mousePressEvent(event)
    
    

    def mouseReleaseEvent(self, event):
        # If we were zooming, reset our zooming flag and cursor.
        if self._zooming:
            self._zooming = False
            self.unsetCursor()
            event.accept()
        super().mouseReleaseEvent(event)
        
    def mouseReleaseEventW(self, event):
        """Handles mouse release event and updates worker selection in combo box."""
    
        #if event.button() == Qt.LeftButton:
        #    self.border = False
        #    self.update()
    
        # Call base class event to maintain behavior
        super().mouseReleaseEvent(event)

        
        
        
        

    def showContextMenu(self, event):
        contextMenu = QMenu()

        #deleteAction = QAction("Delete", contextMenu)
        #deleteAction.triggered.connect(self.deleteItem)
        #contextMenu.addAction(deleteAction)

        lockAction = QAction("Lock", contextMenu)
        lockAction.triggered.connect(self.lockItem)
        contextMenu.addAction(lockAction)

        #rotateAction = QAction("Rotate", contextMenu)
        #rotateAction.triggered.connect(self.rotateItem)
        #contextMenu.addAction(rotateAction)

        #scaleAction = QAction("Scale", contextMenu)
        #scaleAction.triggered.connect(self.scaleItem)
        #contextMenu.addAction(scaleAction)
        
        
        saveAction = QAction("Save", contextMenu)
        saveAction.triggered.connect(self.saveItem)
        contextMenu.addAction(saveAction)
        
        
        # **New Menu Entry to Close Parent Window**
        loadintoToolAction = QAction("Load into Tool Window", contextMenu)
        loadintoToolAction.triggered.connect(self.loadintoToolWindow)
        contextMenu.addAction(loadintoToolAction)

        contextMenu.exec_(event.screenPos())

    
    def loadintoToolWindow(self):
        """Attempts to close the parent window safely."""
        parent = self.parentScene.parent()  # Navigate up to the main window
    
        if parent and hasattr(parent, 'close'):
            self.loadIntoTool = True
            parent.close()  # Trigger the close event
        
        
    def saveItem(self):
        self.__saveData()
        
    def deleteItem(self):
        self.scene().removeItem(self)

    def lockItem(self):
        self.setFlag(QGraphicsItem.ItemIsMovable, False)    

    def rotateItem(self):
        print("Rotate Item")  # Placeholder for actual rotation logic

    def scaleItem(self):
        print("Scale Item")  # Placeholder for actual scaling logic

     


    def __saveData(self):
        """Saves the object's updated data directly to the WorkerStationShiftErgoTool table."""
        
        grandparent = self.parentScene.parent().parent()
        
        if not grandparent or not hasattr(grandparent, 'projectdatabasePath') or not grandparent.projectdatabasePath:
            print("Error: Database path is missing.")
            return
    
        try:
        
            # TODO: temporary fix, it should be from members..
            # **Extract x and y from UI Controls if available**
            #parent = self.parentScene.parent()
            #x_value = float(parent.xcurrentinfo_input.text().strip()) if parent and hasattr(parent, 'xcurrentinfo_input') and parent.xcurrentinfo_input.text().strip() else self.x
            #y_value = float(parent.ycurrentinfo_input.text().strip()) if parent and hasattr(parent, 'ycurrentinfo_input') and parent.ycurrentinfo_input.text().strip() else self.y
            
            #print("self.x=", self.x)
            #print("self.y=", self.y)
            
            #print("self.xi=", self.xi)
            #print("self.yi=", self.yi)
            if (self.x != self.xi):
            #    print("different x coord")
                x_value = self.xi
                x_value = round(float(x_value) - ((float(self.width) * float(self.sfi) * float(self.scale)) / 2)) 
            else:
            #    print("equal x coord")
                x_value = round(self.x)
            
            if (self.y != self.yi):
            #    print("different y coord")
                y_value = self.yi
                y_value = round(float(y_value) - ((float(self.height) * float(self.sfi) * float(self.scale)) / 2))
            else:
            #    print("equal y coord")
                y_value = round(self.y)
            
            #print("x_value=", x_value)
            #print("y_value=", y_value)
            
            
            # TODO: check if it really fix the saving position issue, it seems to help
            #x_value = x_value - (width / 2) 
            #y_value = y_value - (height / 2)
            
            # **Connect to SQLite Database**
            conn = sqlite3.connect(grandparent.projectdatabasePath)
            cursor = conn.cursor()
    
            # **SQL Update Query (Updating all visual fields)**
            query = """
                UPDATE WorkerStationShiftErgoTool 
                SET 
                    x = ?, 
                    y = ?, 
                    width = ?, 
                    height = ?, 
                    line_thickness = ?, 
                    scale_x = ?, 
                    scale_y = ?, 
                    crop_x = ?, 
                    crop_y = ?, 
                    crop_width = ?, 
                    crop_height = ?, 
                    zoom = ?, 
                    rotation = ?, 
                    mirror_h = ?, 
                    mirror_v = ?, 
                    orientation = ?, 
                    brightness = ?, 
                    contrast = ?, 
                    saturation = ?, 
                    lock = ?, 
                    visible = ?, 
                    transparency = ?, 
                    enable = ?, 
                    color = ?
                WHERE worker_id = ? 
                    AND plant_name = ? 
                    AND section_name = ? 
                    AND line_name = ? 
                    AND station_id = ? 
                    AND shift_id = ? 
                    AND tool_id = ?
                """

            # **Prepare Parameters (Including all visual fields)**
            params = (
                x_value, y_value, self.width, self.height, self.line_thickness,
                self.scale, self.scale, self.crop_x, self.crop_y,
                self.crop_width, self.crop_height, self.zoom, self.rotation,
                self.mirror_h, self.mirror_v, self.orientation, self.brightness,
                self.contrast, self.saturation, self.lock, self.visible, self.transparency, self.enable,
                self.color.name(),  # Convert QColor to string (#RRGGBB format)
                self.worker_id, self.plant_name, self.section_name, self.line_name, 
                self.station_id, self.shift_id, self.tool_id
            )

            # **Execute Update**
            cursor.execute(query, params)
            conn.commit()
            conn.close()

            #QMessageBox.information(None, "Save Successful", f"Data saved for Worker ID: {self.worker_id}")
            #QMessageBox.information(grandparent, "Save Successful", f"Data saved for Worker ID: {self.worker_id}")


        except Exception as e:
            print(f"Failed to save data: {str(e)}")


    def saveData(self):
        self.__saveData()
    

    def saveDataAt(self):
        self.__saveDataAt()
        
    def __saveDataAt(self): # TODO: remove it, it should not be needed
        """Saves the object's updated data directly to the WorkerStationShiftErgoTool table."""
        
        grandparent = self.parentScene.parent().parent()
        
        if not grandparent or not hasattr(grandparent, 'projectdatabasePath') or not grandparent.projectdatabasePath:
            print("Error: Database path is missing.")
            return
    
        try:
        
            self.isSaveAt = True
            # TODO: temporary fix, it should be from members..
            # **Extract x and y from UI Controls if available**
            #parent = self.parentScene.parent()
            #x_value = float(parent.xcurrentinfo_input.text().strip()) if parent and hasattr(parent, 'xcurrentinfo_input') and parent.xcurrentinfo_input.text().strip() else self.x
            #y_value = float(parent.ycurrentinfo_input.text().strip()) if parent and hasattr(parent, 'ycurrentinfo_input') and parent.ycurrentinfo_input.text().strip() else self.y
            
            #print("self.x=", self.x)
            #print("self.y=", self.y)
            
            #print("self.xi=", self.xi)
            #print("self.yi=", self.yi)
            if (self.x != self.xi):
            #    print("different x coord")
                x_value = self.xi
                #x_value = round(float(x_value) - ((float(self.width) * float(self.sfi) * float(self.scale)) / 2)) 
            else:
            #    print("equal x coord")
                x_value = round(self.x)
            
            if (self.y != self.yi):
            #    print("different y coord")
                y_value = self.yi
                #y_value = round(float(y_value) - ((float(self.height) * float(self.sfi) * float(self.scale)) / 2))
            else:
            #    print("equal y coord")
                y_value = round(self.y)
            
            #print("x_value=", x_value)
            #print("y_value=", y_value)
            
            
            # TODO: check if it really fix the saving position issue, it seems to help
            #x_value = x_value - (width / 2) 
            #y_value = y_value - (height / 2)
            
            # **Connect to SQLite Database**
            conn = sqlite3.connect(grandparent.projectdatabasePath)
            cursor = conn.cursor()
    
            # **SQL Update Query (Updating all visual fields)**
            query = """
                UPDATE WorkerStationShiftErgoTool 
                SET 
                    x = ?, 
                    y = ?, 
                    width = ?, 
                    height = ?, 
                    line_thickness = ?, 
                    scale_x = ?, 
                    scale_y = ?, 
                    crop_x = ?, 
                    crop_y = ?, 
                    crop_width = ?, 
                    crop_height = ?, 
                    zoom = ?, 
                    rotation = ?, 
                    mirror_h = ?, 
                    mirror_v = ?, 
                    orientation = ?, 
                    brightness = ?, 
                    contrast = ?, 
                    saturation = ?, 
                    lock = ?, 
                    visible = ?, 
                    transparency = ?, 
                    enable = ?, 
                    color = ?
                WHERE worker_id = ? 
                    AND plant_name = ? 
                    AND section_name = ? 
                    AND line_name = ? 
                    AND station_id = ? 
                    AND shift_id = ? 
                    AND tool_id = ?
                """

            # **Prepare Parameters (Including all visual fields)**
            params = (
                x_value, y_value, self.width, self.height, self.line_thickness,
                self.scale, self.scale, self.crop_x, self.crop_y,
                self.crop_width, self.crop_height, self.zoom, self.rotation,
                self.mirror_h, self.mirror_v, self.orientation, self.brightness,
                self.contrast, self.saturation, self.lock, self.visible, self.transparency, self.enable,
                self.color.name(),  # Convert QColor to string (#RRGGBB format)
                self.worker_id, self.plant_name, self.section_name, self.line_name, 
                self.station_id, self.shift_id, self.tool_id
            )

            # **Execute Update**
            cursor.execute(query, params)
            conn.commit()
            conn.close()

            #QMessageBox.information(None, "Save Successful", f"Data saved for Worker ID: {self.worker_id}")
            #QMessageBox.information(grandparent, "Save Successful", f"Data saved for Worker ID: {self.worker_id}")


        except Exception as e:
            print(f"Failed to save data: {str(e)}")


    
    def getAge(self):
        """Calculate approximate age based on birth year"""
        current_year = QDate.currentDate().year()
        return current_year - self.year_of_birth if self.year_of_birth else "N/A"

    def getLoadIntoTool(self):
        """Returns the current value of loadIntoTool."""
        return self.loadIntoTool
    
    def getBorder(self):
        """Gets the border status."""
        return self.border
    
    def getUnit(self):
        """Gets the border status."""
        return self.unit
        
    # **Plant, Section, Line, Station, Shift, Tool Identifiers**
    def getPlantName(self):
        return self.plant_name
    
    def getSectionName(self):
        return self.section_name

    def getLineName(self):
        return self.line_name
    
    def getStationID(self):
        return self.station_id
    
    def getShiftID(self):
        return self.shift_id
    
    def getToolID(self):
        return self.tool_id

    # **Worker Identification & Details**
    def getWorkerID(self):
        return self.worker_id
    
    def getFirstName(self):
        return self.first_name
    
    def getLastName(self):
        return self.last_name
    
    def getFullName(self):
        return f"{self.first_name} {self.last_name}".strip()
    
    def getYearOfBirth(self):
        return self.year_of_birth
    
    def getMonthOfBirth(self):
        return self.month_of_birth
    
    def getDayOfBirth(self):
        return self.day_of_birth
    
    def getGender(self):
        return self.gender
    
    # **Worker Physical Attributes**
    def getWorkerHeight(self):
        return self.worker_height  # Explicitly mapped from "worker_height" field
    
    def getWorkerWeight(self):
        return self.worker_weight  # Explicitly mapped from "worker_weight" field
    
    # **Risk & Damage Metrics**
    def getTotalCumulativeDamage(self):
        return self.total_cumulative_damage
    
    def getProbabilityOutcome(self):
        return self.probability_outcome
    
    # **Additional Results**
    def getResult3(self):
        return self.result_3
    
    def getResult4(self):
        return self.result_4
    
    def getResult5(self):
        return self.result_5
    
    def getResult6(self):
        return self.result_6
    
    def getResult7(self):
        return self.result_7
    
    def getResult8(self):
        return self.result_8
    
    def getResult9(self):
        return self.result_9
    
    # **Visual Positioning & Dimensions**
    def getX(self):
        return self.xi

    def getY(self):
        return self.yi
    
    def getWidth(self):
        return self.width
    
    def getHeight(self):
        return self.height
    
    def getLineThickness(self):
        return self.line_thickness
    
    def getScaleX(self):
        return self.scale_x
    
    def getScaleY(self):
        return self.scale_y
    
    def getScale(self):
        return self.scale
        
    def getRotation(self):
        return self.rotation
    
    def getZoom(self):
        return self.zoom
    
    # **Cropping**
    def getCropX(self):
        return self.crop_x
    
    def getCropY(self):
        return self.crop_y
    
    def getCropWidth(self):
        return self.crop_width
    
    def getCropHeight(self):
        return self.crop_height
    
    # **Mirroring & Orientation**
    def getMirrorH(self):
        return self.mirror_h    

    def getMirrorV(self):
        return self.mirror_v

    def getOrientation(self):
        return self.orientation
    
    # **Color & Transparency**
    def getColor(self):
        return self.color  # QColor object
    
    def getBrightness(self):
        return self.brightness
    
    def getContrast(self):
        return self.contrast
    
    def getSaturation(self):
        return self.saturation

    def getTransparency(self):
        return self.transparency
    
    # **State & Visibility**
    def isLocked(self):
        return self.lock == 1
    
    def isVisible(self):
        return self.visible == 1
    
    def isEnabled(self):
        return self.enable == 1
    
    # **Shape Type**
    def getShape(self):
        return self.shape  # "circle", "triangle", or "square"
    
    
    def setBorder(self, border):
        """Sets the border status."""
        self.border = border
        self.update()
    
    def setLoadIntoTool(self, value):
        """Sets the value of loadIntoTool with validation."""
        if isinstance(value, bool):  # Ensure it's a boolean
            self.loadIntoTool = value
        #else:
        #    print("Error: loadIntoTool must be a boolean value (True or False).")


    # **Worker Identification & Details**
    def setWorkerID(self, worker_id):
        self.worker_id = worker_id
        self.datarow["worker_id"] = worker_id
    
    def setFirstName(self, first_name):
        self.first_name = first_name
        self.datarow["first_name"] = first_name
    
    def setLastName(self, last_name):
        self.last_name = last_name
        self.datarow["last_name"] = last_name
    
    def setYearOfBirth(self, year):
        self.year_of_birth = year
        self.datarow["year_of_birth"] = year
    
    def setMonthOfBirth(self, month):
        self.month_of_birth = month
        self.datarow["month_of_birth"] = month
    
    def setDayOfBirth(self, day):
        self.day_of_birth = day
        self.datarow["day_of_birth"] = day
    
    def setGender(self, gender):
        self.gender = gender
        self.datarow["gender"] = gender
        self.initShape()  # Recalculate shape based on gender change
    
    # **Worker Physical Attributes**
    def setWorkerHeight(self, height):
        self.worker_height = height
        self.datarow["worker_height"] = height
    
    def setWorkerWeight(self, weight):
        self.worker_weight = weight
        self.datarow["worker_weight"] = weight
    
    # **Workstation Assignment**
    def setPlantName(self, plant_name):
        self.plant_name = plant_name
        self.datarow["plant_name"] = plant_name
    
    def setSectionName(self, section_name):
        self.section_name = section_name
        self.datarow["section_name"] = section_name
    
    def setLineName(self, line_name):
        self.line_name = line_name
        self.datarow["line_name"] = line_name
    
    def setStationID(self, station_id):
        self.station_id = station_id
        self.datarow["station_id"] = station_id

    def setShiftID(self, shift_id):
        self.shift_id = shift_id
        self.datarow["shift_id"] = shift_id
    
    def setToolID(self, tool_id):
        self.tool_id = tool_id
        self.datarow["tool_id"] = tool_id
    
    # **Ergonomic Analysis**
    def setTotalCumulativeDamage(self, damage):
        self.total_cumulative_damage = damage
        self.datarow["total_cumulative_damage"] = damage        
    
    def setProbabilityOutcome(self, probability):
        self.probability_outcome = probability
        self.datarow["probability_outcome"] = probability

    # **Additional Result Fields**
    def setResult3(self, result):
        self.result_3 = result
        self.datarow["result_3"] = result
    
    def setResult4(self, result):
        self.result_4 = result
        self.datarow["result_4"] = result
    
    def setResult5(self, result):
        self.result_5 = result
        self.datarow["result_5"] = result
    
    def setResult6(self, result):
        self.result_6 = result
        self.datarow["result_6"] = result

    def setResult7(self, result):
        self.result_7 = result
        self.datarow["result_7"] = result
    
    def setResult8(self, result):
        self.result_8 = result
        self.datarow["result_8"] = result
    
    def setResult9(self, result):
        self.result_9 = result
        self.datarow["result_9"] = result
    
    def setUnit(self, unit):
        self.unit = unit
        self.datarow["unit"] = unit
        
    # **Visual Elements**
    def setX(self, x):
        self.xi =  round(float(x), 1)
        self.datarow["x"] = x
        #self.initShape()  # Update graphical position
        self.update()
    
    def setY(self, y):
        self.yi =  round(float(y), 1)
        self.datarow["y"] = y
        #self.initShape()  # Update graphical position
        self.update()
    
    def setWidth(self, width):
        self.width = width
        self.datarow["width"] = width
        self.initShape()  # Resize shape

    def setHeight(self, height):
        self.height = height
        self.datarow["ws_height"] = height
        self.initShape()  # Resize shape
    
    def setLineThickness(self, thickness):
        self.line_thickness = thickness
        self.datarow["line_thickness"] = thickness
    
    def setScaleX(self, scale_x):
        self.scale_x = scale_x
        self.scale = self.scale_x
        self.datarow["scale_x"] = scale_x
    
    def setScaleY(self, scale_y):
        self.scale_y = scale_y
        self.scale = self.scale_y
        self.datarow["scale_y"] = scale_y
        
    def setScale(self, scale):
        self.scale_x = scale
        self.scale_y = scale
        self.scale = scale
        self.datarow["scale_x"] = self.scale_x
        self.datarow["scale_y"] = self.scale_y    
    
    def setCropX(self, crop_x):
        self.crop_x = crop_x
        self.datarow["crop_x"] = crop_x
    
    def setCropY(self, crop_y):
        self.crop_y = crop_y
        self.datarow["crop_y"] = crop_y
    
    def setCropWidth(self, crop_width):
        self.crop_width = crop_width
        self.datarow["crop_width"] = crop_width
    
    def setCropHeight(self, crop_height):
        self.crop_height = crop_height
        self.datarow["crop_height"] = crop_height
    
    def setZoom(self, zoom):
        self.zoom = zoom
        self.datarow["zoom"] = zoom
    
    def setRotation(self, rotation):
        self.rotation = rotation
        self.datarow["rotation"] = rotation
    
    def setMirrorH(self, mirror_h):
        self.mirror_h = mirror_h
        self.datarow["mirror_h"] = mirror_h

    def setMirrorV(self, mirror_v):
        self.mirror_v = mirror_v
        self.datarow["mirror_v"] = mirror_v
    
    def setOrientation(self, orientation):
        self.orientation = orientation
        self.datarow["orientation"] = orientation
    
    def setBrightness(self, brightness):
        self.brightness = brightness
        self.datarow["brightness"] = brightness
    
    def setContrast(self, contrast):
        self.contrast = contrast
        self.datarow["contrast"] = contrast

    def setSaturation(self, saturation):
        self.saturation = saturation
        self.datarow["saturation"] = saturation
    
    def setLock(self, lock):
        self.lock = lock
        self.datarow["lock"] = lock
        # If lock is 1 (locked), disable movement; otherwise, enable it
        self.setFlag(QGraphicsItem.ItemIsMovable, lock == 0)   

    
    def setVisible(self, visible):
        self.visible = visible
        self.datarow["visible"] = visible
        if visible:
            self.parentScene.addItem(self)  # Add to scene only if visible
        else:
            self.parentScene.removeItem(self)  # Remove from scene if not visible
    
    def setTransparency(self, transparency):
        self.transparency = transparency
        self.datarow["transparency"] = transparency
    
    def setEnable(self, enable):
        self.enable = enable
        self.datarow["enable"] = enable
    
    # **Color Handling**
    def setColor(self, hex_color):
        self.color = QColor(hex_color)
        self.datarow["color"] = hex_color
        if hasattr(self, 'item') and self.item:
            self.item.setBrush(QBrush(self.color, Qt.SolidPattern))  # Update color immediately












